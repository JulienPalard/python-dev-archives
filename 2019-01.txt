From mertz at gnosis.cx  Wed Jan  2 12:34:55 2019
From: mertz at gnosis.cx (David Mertz)
Date: Wed, 2 Jan 2019 12:34:55 -0500
Subject: [Python-Dev] Interested in serving on Steering Council
Message-ID: <CAEbHw4bhjt3k-Q57BnSWw150B2Pint1465ick+775i-eaYeVBA@mail.gmail.com>

Hi Core Developers,

First thing: I am *not* a CPython committer.  I think most of you who are
will be somewhat familiar with me though.

Second: I was a Director of the PSF for a long while, and continue to chair
some Working Groups.  I've been mentioned in some PEPs.  I have written a
lot of articles and have given a lot of talks about Python, including about
recent or pending PEPs and similar matters.  I continue to work and train
around Python and open source (now with a focus on "data science", whatever
that is).

Third: I follow python-ideas and python-dev rather closely, and fairly
often contribute ideas to those lists.

Fourth: As I read PEP 8016, I cannot nominate myself to the Steering
Committee.  That seems good and proper to me.  But I believe I would be a
relevant and helpful member of the future Steering Committee if someone
wishes to nominate me and if the voters wish to elect me.

Thanks, David Mertz...

-- 
Keeping medicines from the bloodstreams of the sick; food
from the bellies of the hungry; books from the hands of the
uneducated; technology from the underdeveloped; and putting
advocates of freedom in prisons.  Intellectual property is
to the 21st century what the slave trade was to the 16th.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.python.org/pipermail/python-dev/attachments/20190102/bd4b3ea4/attachment.html>

From solipsis at pitrou.net  Wed Jan  2 13:15:17 2019
From: solipsis at pitrou.net (Antoine Pitrou)
Date: Wed, 2 Jan 2019 19:15:17 +0100
Subject: [Python-Dev] Interested in serving on Steering Council
References: <CAEbHw4bhjt3k-Q57BnSWw150B2Pint1465ick+775i-eaYeVBA@mail.gmail.com>
Message-ID: <20190102191517.7fc2094c@fsol>

On Wed, 2 Jan 2019 12:34:55 -0500
David Mertz <mertz at gnosis.cx> wrote:
> Hi Core Developers,
> 
> First thing: I am *not* a CPython committer.  I think most of you who are
> will be somewhat familiar with me though.
> 
> Second: I was a Director of the PSF for a long while, and continue to chair
> some Working Groups.  I've been mentioned in some PEPs.  I have written a
> lot of articles and have given a lot of talks about Python, including about
> recent or pending PEPs and similar matters.  I continue to work and train
> around Python and open source (now with a focus on "data science", whatever
> that is).
> 
> Third: I follow python-ideas and python-dev rather closely, and fairly
> often contribute ideas to those lists.
> 
> Fourth: As I read PEP 8016, I cannot nominate myself to the Steering
> Committee.  That seems good and proper to me.  But I believe I would be a
> relevant and helpful member of the future Steering Committee if someone
> wishes to nominate me and if the voters wish to elect me.

The primary question I would ask an external candidate is: how is it
that you never became a core developer (which implies some amount of
effort and dedication) but nevertheless would be willing to spend the
effort and dedication needed for serving on a Steering Council (*)?

(*) (or Committee, I don't remember :-))

Regards

Antoine.



From paul at ganssle.io  Wed Jan  2 14:15:43 2019
From: paul at ganssle.io (Paul Ganssle)
Date: Wed, 2 Jan 2019 14:15:43 -0500
Subject: [Python-Dev] Return type of datetime subclasses added to timedelta
Message-ID: <1059740e-cc65-205d-5986-a9397463a315@ganssle.io>

Happy New Year everyone!

I would like to start a thread here for wider feedback on my proposal to
change the return type of the addition operation between a datetime
subclass and a timedelta. Currently, adding a timedelta to a subclass of
datetime /always/ returns a datetime rather than an instance of the
datetime subclass.

I have an open PR implementing this, PR #10902
<https://github.com/python/cpython/pull/10902>, but I know it's a major
change so I did not want to move forward without more discussion. I
first brought this up on datetime-SIG
<https://mail.python.org/archives/list/datetime-sig at python.org/thread/TGB3VZS5EKM4R2VFUA44323FZFRN2DSJ/>
[1], and we decided to move the discussion over here because the people
most likely to object to the change would be on this list and not on
datetime-SIG.

In addition to the datetime-SIG thread, you may find a detailed
rationale for the change in bpo-35364
<https://bugs.python.org/issue35364#msg331065> [2],? and a rationale for
why we would want to (and arguably already /do/) support subclassing
datetime in bpo-32417 <https://bugs.python.org/issue32417#msg331353> [3].

A short version of the strongest rationale for changing how this works
is that it is causing inconsistencies in how subclassing is handled in
alternate constructors of datetime. For a given subclass of datetime
(which I will call DateTimeSub), nearly all alternate constructors
already support subclasses correctly - DateTimeSub.fromtimestamp(x) will
return a DateTimeSub, for example. However, because DateTimeSub +
timedelta returns datetime, any alternate constructor implemented in
terms of timedelta additions will leak that implementation detail by
returning a datetime object instead of the subclass. The biggest problem
is that datetime.fromutc is defined in terms of timedelta addition, so
DateTimeSub.now() returns a DateTimeSub object, but
DateTimeSub.now(timezone.utc) returns a datetime object! This is one of
the most annoying things to work around when building a datetime
subclass, and I don't know of any situation where someone /wants/ their
subclass to be lost on addition with a timedelta.

From my understanding, this has been discussed before and the original
objection was that this implementation assumes that the datetime
subclass has a constructor with the same (or a sufficiently similar)
signature as datetime. This may be a legitimate gripe, but unfortunately
that ship has sailed long ago. All of datetime's alternate constructors
make this assumption. Any subclass that does not meet this requirement
must have worked around it long ago (or they don't care about alternate
constructors).

Thanks for your attention, I look forward to your replies.

Best,

Paul

[1]
https://mail.python.org/archives/list/datetime-sig at python.org/thread/TGB3VZS5EKM4R2VFUA44323FZFRN2DSJ/

[2] https://bugs.python.org/issue35364#msg331065

[3] https://bugs.python.org/issue32417#msg331353


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.python.org/pipermail/python-dev/attachments/20190102/87450a51/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: OpenPGP digital signature
URL: <http://mail.python.org/pipermail/python-dev/attachments/20190102/87450a51/attachment.sig>

From steve.dower at python.org  Thu Jan  3 22:27:10 2019
From: steve.dower at python.org (Steve Dower)
Date: Fri, 4 Jan 2019 14:27:10 +1100
Subject: [Python-Dev] Interested in serving on Steering Council
In-Reply-To: <20190102191517.7fc2094c@fsol>
References: <CAEbHw4bhjt3k-Q57BnSWw150B2Pint1465ick+775i-eaYeVBA@mail.gmail.com>
 <20190102191517.7fc2094c@fsol>
Message-ID: <cb08756a-cf4b-f6ad-5147-7ef3e41f4c95@python.org>

On 03Jan.2019 0515, Antoine Pitrou wrote:
> The primary question I would ask an external candidate is: how is it
> that you never became a core developer (which implies some amount of
> effort and dedication) but nevertheless would be willing to spend the
> effort and dedication needed for serving on a Steering Council (*)?
> 
> (*) (or Committee, I don't remember :-)
David may of course provide an answer for himself, but allow me to
provide my answer (and this is why I pushed for allowing external
nominations).

Historically, the only reason to become a core committer was to commit
code. Some of us no doubt desired or demonstrated greater influence, but
all of us have committed code or reviewed and merged PRs, either
directly to CPython or one of the related projects.

This is not a job for everyone, but it's been the only job we had on offer.

The closest alternative job was to be elected to the board of the Python
Software Foundation. But this is still not a job for everyone. They also
are not considered core committers, despite making significant
contributions.

We now have a new job on offer. Exactly what that job involves isn't
quite defined yet, but it will certainly include some amount of
project/program/process management, likely some customer/user engagement
(or relationship management, if you prefer), and potentially some
independent decision making.

Guido is the only core developer who has previously contributed to
Python in this way (whatever "this way" turns out to mean). The rest of
us happily worked under "someone else" doing it.

Meanwhile, many non-core committers in the Python community have spent
their time building companies, consulting businesses or educational
courses. Spending time writing code and reviewing PRs is not how they
want to contribute, and so they have contributed in other ways -
including writing and often reviewing PEPs. There was no need for them
to be a core committer, since they weren't doing any of the
committer-specific tasks.

In the PEP 8016 discussions (pre vote), we agreed that if we chose to
elect someone who is not currently a core developer, we would also
probably vote to make them a core developer, so there is no harm in
allowing externals to be nominated. Also since the core committers are
voluntarily submitting to their guidance, it makes sense that voting to
elect/dissolve is restricted to us.

In summary, members of the Steering Council are filling a new role with
only one explicit precedent within the core committers. The
qualifications are different, and so the pool of candidates is
different. The existing core committers will submit to the Steering
Council, and so are the ones who elect them.

(Note that I've carefully used "core committer" and "core developer"
above. I believe it's very important to distinguish between "write
access on GitHub" and "project decision maker", and no reason to force
an arbitrary overlap.)

Cheers,
Steve

From solipsis at pitrou.net  Fri Jan  4 05:04:54 2019
From: solipsis at pitrou.net (Antoine Pitrou)
Date: Fri, 4 Jan 2019 11:04:54 +0100
Subject: [Python-Dev] Interested in serving on Steering Council
In-Reply-To: <cb08756a-cf4b-f6ad-5147-7ef3e41f4c95@python.org>
References: <CAEbHw4bhjt3k-Q57BnSWw150B2Pint1465ick+775i-eaYeVBA@mail.gmail.com>
 <20190102191517.7fc2094c@fsol>
 <cb08756a-cf4b-f6ad-5147-7ef3e41f4c95@python.org>
Message-ID: <20190104110454.045cb0de@fsol>

On Fri, 4 Jan 2019 14:27:10 +1100
Steve Dower <steve.dower at python.org> wrote:
> 
> We now have a new job on offer. Exactly what that job involves isn't
> quite defined yet, but it will certainly include some amount of
> project/program/process management, likely some customer/user engagement
> (or relationship management, if you prefer), and potentially some
> independent decision making.
> 
> Guido is the only core developer who has previously contributed to
> Python in this way (whatever "this way" turns out to mean).

Not exactly.  Nick's role on packaging comes to mind.  More modestly,
several of us have served as BDFL delegates, have steered various
processes (such as VCS migration), and/or have been responsible
(officially or not) for subparts of the project (such as documentation,
buildbots, version control...).

> In the PEP 8016 discussions (pre vote), we agreed that if we chose to
> elect someone who is not currently a core developer, we would also
> probably vote to make them a core developer, so there is no harm in
> allowing externals to be nominated.

The Council is going to be a 5-person body, some some amount of
involvement and dedication is expected from each of the Council's
members if we want it to function correctly (it's probably not just a
supervision body where you can participate in a meeting every 3 months,
answer a couple e-mails and call it done).

I already have a hard time imagining my level of involvement being
enough for candidating on the Council.  So I would be skeptical of
voting for someone who hasn't submitted a single patch to the codebase
in 10+ years, for example.

Moreover, someone who has never contributed to the codebase hasn't
really experienced how contributing works, which doesn't make them a
very good candidate for managing contributors, IMHO.

Regards

Antoine.

From status at bugs.python.org  Fri Jan  4 13:07:38 2019
From: status at bugs.python.org (Python tracker)
Date: Fri, 04 Jan 2019 18:07:38 +0000
Subject: [Python-Dev] Summary of Python tracker Issues
Message-ID: <20190104180738.1.A332AF26462CD784@roundup.psfhosted.org>


ACTIVITY SUMMARY (2018-12-28 - 2019-01-04)
Python tracker at https://bugs.python.org/

To view or respond to any of the issues listed below, click on the issue.
Do NOT respond to this message.

Issues counts and deltas:
  open    6922 (+19)
  closed 40487 (+34)
  total  47409 (+53)

Open issues with patches: 2748 


Issues opened (34)
==================

#35606: Add prod() function to the math module
https://bugs.python.org/issue35606  opened by rhettinger

#35608: python3 multiprocessing queue deadlock when use thread and pro
https://bugs.python.org/issue35608  opened by beruhan

#35610: IDLE: replace use of EditorWindow.context_use_ps1
https://bugs.python.org/issue35610  opened by terry.reedy

#35611: open doesn't call IncrementalEncoder with final=True
https://bugs.python.org/issue35611  opened by haney

#35615: "RuntimeError: Dictionary changed size during iteration" when 
https://bugs.python.org/issue35615  opened by ltfish

#35616: Change references to '4.0'.
https://bugs.python.org/issue35616  opened by terry.reedy

#35617: unittest discover does not work with implicit namespaces
https://bugs.python.org/issue35617  opened by Simon Fagerholm

#35618: Allow users to set suffix list in cookiejar policy
https://bugs.python.org/issue35618  opened by xtreak

#35619: Support custom data descriptors in pydoc
https://bugs.python.org/issue35619  opened by serhiy.storchaka

#35620: asyncio test failure on appveyor
https://bugs.python.org/issue35620  opened by terry.reedy

#35621: asyncio.create_subprocess_exec() only works with main event lo
https://bugs.python.org/issue35621  opened by sth

#35622: Add support for Linux SCHED_DEADLINE
https://bugs.python.org/issue35622  opened by mb_

#35624: Shelve sync issues while using Gevent
https://bugs.python.org/issue35624  opened by Oded Engel

#35625: documentation of list, set & dict comprehension make no mentio
https://bugs.python.org/issue35625  opened by bzip2

#35627: multiprocessing.queue in 3.7.2 doesn't behave as it was in 3.7
https://bugs.python.org/issue35627  opened by June Kim

#35628: Allow lazy loading of translations in gettext.
https://bugs.python.org/issue35628  opened by s-ball

#35629: hang and/or leaked processes with multiprocessing.Pool(...).im
https://bugs.python.org/issue35629  opened by Anthony Sottile

#35632: support unparse for Suite ast
https://bugs.python.org/issue35632  opened by thautwarm

#35633: test_eintr fails on AIX since fcntl functions were modified
https://bugs.python.org/issue35633  opened by Michael.Felt

#35634: kwargs regression when there are multiple entries with the sam
https://bugs.python.org/issue35634  opened by iceboy

#35635: asyncio.create_subprocess_exec() only works in main thread
https://bugs.python.org/issue35635  opened by stefan

#35636: remove redundant check in unicode_hash(PyObject *self)
https://bugs.python.org/issue35636  opened by Ma Lin

#35638: Introduce fixed point locale aware format type for floating po
https://bugs.python.org/issue35638  opened by steelman

#35639: Lowecasing Unicode Characters
https://bugs.python.org/issue35639  opened by kingofsevens

#35640: Allow passing PathLike arguments to SimpleHTTPRequestHandler
https://bugs.python.org/issue35640  opened by eamanu

#35642: _asynciomodule.c compiled in both pythoncore.vcxproj and _asyn
https://bugs.python.org/issue35642  opened by Gregory.Szorc

#35644: venv doesn't work on Windows when no venvlauncher executable p
https://bugs.python.org/issue35644  opened by Ray Donnelly

#35647: Cookie path check returns incorrect results
https://bugs.python.org/issue35647  opened by xtreak

#35649: http.client doesn't close. Infinite loop
https://bugs.python.org/issue35649  opened by skorpeo

#35651: PEP 257 (active) references PEP 258 (rejected) as if it were a
https://bugs.python.org/issue35651  opened by ExplodingCabbage

#35652: Add use_srcentry parameter to shutil.copytree() II
https://bugs.python.org/issue35652  opened by flokX

#35654: Remove 'guarantee' that sorting only relies on __lt__ from sor
https://bugs.python.org/issue35654  opened by mjpieters

#35656: More matchers in unittest.mock
https://bugs.python.org/issue35656  opened by Petter S

#35657: multiprocessing.Process.join() ignores timeout if child proces
https://bugs.python.org/issue35657  opened by Huazuo Gao



Most recent 15 issues with no replies (15)
==========================================

#35656: More matchers in unittest.mock
https://bugs.python.org/issue35656

#35652: Add use_srcentry parameter to shutil.copytree() II
https://bugs.python.org/issue35652

#35651: PEP 257 (active) references PEP 258 (rejected) as if it were a
https://bugs.python.org/issue35651

#35647: Cookie path check returns incorrect results
https://bugs.python.org/issue35647

#35642: _asynciomodule.c compiled in both pythoncore.vcxproj and _asyn
https://bugs.python.org/issue35642

#35640: Allow passing PathLike arguments to SimpleHTTPRequestHandler
https://bugs.python.org/issue35640

#35635: asyncio.create_subprocess_exec() only works in main thread
https://bugs.python.org/issue35635

#35632: support unparse for Suite ast
https://bugs.python.org/issue35632

#35628: Allow lazy loading of translations in gettext.
https://bugs.python.org/issue35628

#35625: documentation of list, set & dict comprehension make no mentio
https://bugs.python.org/issue35625

#35622: Add support for Linux SCHED_DEADLINE
https://bugs.python.org/issue35622

#35621: asyncio.create_subprocess_exec() only works with main event lo
https://bugs.python.org/issue35621

#35619: Support custom data descriptors in pydoc
https://bugs.python.org/issue35619

#35618: Allow users to set suffix list in cookiejar policy
https://bugs.python.org/issue35618

#35610: IDLE: replace use of EditorWindow.context_use_ps1
https://bugs.python.org/issue35610



Most recent 15 issues waiting for review (15)
=============================================

#35652: Add use_srcentry parameter to shutil.copytree() II
https://bugs.python.org/issue35652

#35642: _asynciomodule.c compiled in both pythoncore.vcxproj and _asyn
https://bugs.python.org/issue35642

#35638: Introduce fixed point locale aware format type for floating po
https://bugs.python.org/issue35638

#35636: remove redundant check in unicode_hash(PyObject *self)
https://bugs.python.org/issue35636

#35633: test_eintr fails on AIX since fcntl functions were modified
https://bugs.python.org/issue35633

#35619: Support custom data descriptors in pydoc
https://bugs.python.org/issue35619

#35617: unittest discover does not work with implicit namespaces
https://bugs.python.org/issue35617

#35616: Change references to '4.0'.
https://bugs.python.org/issue35616

#35615: "RuntimeError: Dictionary changed size during iteration" when 
https://bugs.python.org/issue35615

#35610: IDLE: replace use of EditorWindow.context_use_ps1
https://bugs.python.org/issue35610

#35606: Add prod() function to the math module
https://bugs.python.org/issue35606

#35605: backported patch requires new sphinx, minimum sphinx version w
https://bugs.python.org/issue35605

#35603: table header in output of difflib.HtmlDiff.make_table is not e
https://bugs.python.org/issue35603

#35598: IDLE: Modernize config_key module
https://bugs.python.org/issue35598

#35596: Fatal Python error: initfsencoding: unable to load the file sy
https://bugs.python.org/issue35596



Top 10 most discussed issues (10)
=================================

#35598: IDLE: Modernize config_key module
https://bugs.python.org/issue35598  11 msgs

#35638: Introduce fixed point locale aware format type for floating po
https://bugs.python.org/issue35638  10 msgs

#35431: Add a function for computing binomial coefficients to the math
https://bugs.python.org/issue35431   9 msgs

#35636: remove redundant check in unicode_hash(PyObject *self)
https://bugs.python.org/issue35636   9 msgs

#35605: backported patch requires new sphinx, minimum sphinx version w
https://bugs.python.org/issue35605   8 msgs

#35214: Get the test suite passing with clang Memory Sanitizer enabled
https://bugs.python.org/issue35214   7 msgs

#35644: venv doesn't work on Windows when no venvlauncher executable p
https://bugs.python.org/issue35644   7 msgs

#35603: table header in output of difflib.HtmlDiff.make_table is not e
https://bugs.python.org/issue35603   6 msgs

#35608: python3 multiprocessing queue deadlock when use thread and pro
https://bugs.python.org/issue35608   6 msgs

#35654: Remove 'guarantee' that sorting only relies on __lt__ from sor
https://bugs.python.org/issue35654   6 msgs



Issues closed (34)
==================

#19120: shlex.shlex.lineno reports a different number depending on the
https://bugs.python.org/issue19120  closed by cheryl.sabella

#20182: Derby #13: Convert 50 sites to Argument Clinic across 5 files
https://bugs.python.org/issue20182  closed by taleinat

#20849: add exist_ok to shutil.copytree
https://bugs.python.org/issue20849  closed by giampaolo.rodola

#28503: [Patch] '_crypt' module: fix implicit declaration of crypt(), 
https://bugs.python.org/issue28503  closed by gregory.p.smith

#32492: C Fast path for namedtuple's property/itemgetter pair
https://bugs.python.org/issue32492  closed by rhettinger

#33234: Improve list() pre-sizing for inputs with known lengths
https://bugs.python.org/issue33234  closed by pablogsal

#33987: IDLE: use ttk.Frame for ttk widgets
https://bugs.python.org/issue33987  closed by terry.reedy

#34055: IDLE: erroneous 'smart' indents in shell
https://bugs.python.org/issue34055  closed by terry.reedy

#35225: test_faulthandler fails under ubsan
https://bugs.python.org/issue35225  closed by gregory.p.smith

#35570: 2to3 creates code using deprecated imp module
https://bugs.python.org/issue35570  closed by terry.reedy

#35583: (glibc2.28/MIPS32EL) python 3.7.x interpreter segmentation fau
https://bugs.python.org/issue35583  closed by broly

#35588: Speed up mod/divmod/floordiv for Fraction type
https://bugs.python.org/issue35588  closed by serhiy.storchaka

#35594: Python script generating Segmentation Fault
https://bugs.python.org/issue35594  closed by terry.reedy

#35601: Race condition in test_signal_handling_args x86-64 High Sierra
https://bugs.python.org/issue35601  closed by pablogsal

#35602: cleanup code may fail in test_asyncio.test_unix_events.Selecto
https://bugs.python.org/issue35602  closed by pablogsal

#35607: python3 multiprocessing queue deadlock when use thread and pro
https://bugs.python.org/issue35607  closed by beruhan

#35609: Improve of abc.py docstring
https://bugs.python.org/issue35609  closed by serhiy.storchaka

#35612: Text wrap over text containing tab character
https://bugs.python.org/issue35612  closed by Devika Sondhi

#35613: Escaping string containing invalid characters as per XML
https://bugs.python.org/issue35613  closed by ned.deily

#35614: Broken help() on metaclasses
https://bugs.python.org/issue35614  closed by ncoghlan

#35623: Segfault in test_bigmem.ListTest.test_sort
https://bugs.python.org/issue35623  closed by benjamin.peterson

#35626: Python dictreader KeyError issue
https://bugs.python.org/issue35626  closed by eric.smith

#35630: Missing code tag for "python3" in README.rst
https://bugs.python.org/issue35630  closed by benjamin.peterson

#35631: Improve typing docs wrt abstract/concrete collection types
https://bugs.python.org/issue35631  closed by levkivskyi

#35637: Factorial should be able to evaluate float arguments
https://bugs.python.org/issue35637  closed by serhiy.storchaka

#35641: IDLE: calltips not properly formatted for functions without do
https://bugs.python.org/issue35641  closed by taleinat

#35643: SyntaxWarning: invalid escape sequence in Modules/_sha3/cleanu
https://bugs.python.org/issue35643  closed by benjamin.peterson

#35645: Alarm usage
https://bugs.python.org/issue35645  closed by steven.daprano

#35646: python -v writes to stderr
https://bugs.python.org/issue35646  closed by eric.smith

#35648: Add use_srcentry parameter to shutil.copytree()
https://bugs.python.org/issue35648  closed by flokX

#35650: cygwin treats X and X.exe as the same file
https://bugs.python.org/issue35650  closed by zach.ware

#35653: All regular expression match groups are the empty string
https://bugs.python.org/issue35653  closed by mrabarnett

#35655: documentation have wrong info about fibo module examples
https://bugs.python.org/issue35655  closed by christian.heimes

#35658: Reggie_Linear_Regression_Solution.ipynb devide by 10 diff with
https://bugs.python.org/issue35658  closed by steven.daprano

From mertz at gnosis.cx  Fri Jan  4 15:24:20 2019
From: mertz at gnosis.cx (David Mertz)
Date: Fri, 4 Jan 2019 15:24:20 -0500
Subject: [Python-Dev] Interested in serving on Steering Council
In-Reply-To: <cb08756a-cf4b-f6ad-5147-7ef3e41f4c95@python.org>
References: <CAEbHw4bhjt3k-Q57BnSWw150B2Pint1465ick+775i-eaYeVBA@mail.gmail.com>
 <20190102191517.7fc2094c@fsol>
 <cb08756a-cf4b-f6ad-5147-7ef3e41f4c95@python.org>
Message-ID: <CAEbHw4b-dWKeYWaYoGBS1HMxJjuN0gquM99mKfuNvvU3wmwzGQ@mail.gmail.com>

I do not wish to presume too much on the judgement of the core developers.
But I thank Steve Dower for his characterizations which pretty much exactly
explain why I've had those involvements with the Python community and
language I have had, and haven't done other things.

I've been part of the Python community since 1998, but really active in it
since about 2001.  During the early 2000s, I wrote a large number of widely
read articles promoting Python, often delving into explaining semi-obscure
features and language design issues.  Most of these were with in my column
_Charming Python_.  I believe that several changes in Python itself?such as
making coroutines easier to use and the design of metaclasses and class
decorators?were significantly influenced by things I wrote on the topics.

Mostly in the period after writing that column, i.e. during the 2010s, I
served as a Director of the PSF; both before and since my time as a
Director, I've chaired several PSF committees.  That likewise felt like a
way I could advance Python best, but from more of an organizational or
social perspective than a technical one.  It is interesting to me that
whereas when I started volunteering for the PSF, there was significant
overlap between the PSF board and the core-committers, I think there is
little or no overlap today.  For better or worse, PSF is much more
community than technical today.  I feel like my own skills and interest
remain somewhat at the intersection of those aspects of Python.

I did not choose during that time, nor since, to become a CPython core
developer.  I've certainly contributed to other projects in the Python
ecosystem (I'm not sure if those are "related projects" in the sense Steve
mentions).  Part of that is time commitment needed, but more of it is my
personal strategic choices about what I could best do to advance Python in
the world.  I've felt I can do more by writing, speaking, and participating
in the PSF, than I would have by working on the CPython code base itself.

In particular, I always felt that I am not nearly as strong of a *C*
developer as are most core developers.  In Python itself, yes, but not in
C.  I am certain that I could have found some small bug to fix or small
feature to add, and gotten it accepted.  But doing that would have taken me
comparatively more effort than it would many others; I felt that effort was
better targeted towards educating Python users and teaching the user-level
language design choices Python has made.

If the core developers feel that the overwhelming qualification for the
Steering Committee is familiarity with the C code base of CPython, then
indeed I am not the best candidate for that.  If language design issues are
more important?and especially if thinking about Python's place among users
and industry are important, then I think I'm a very good candidate for the
role.  In particular, I believe my judgement about "Is this feature good
for Python users?" would be as good as that of most anyone (maybe other
than Guido); but I recognize that my judgement about "Is this feature
straightforward to implement in CPython?" or "What are the performance
implications of this features?" are weaker than those of most core
developers.  Not to say I have *no* instinct about those other questions,
but I know to defer.

Best, David...


> (*) (or Committee, I don't remember :-)
> David may of course provide an answer for himself, but allow me to
> provide my answer (and this is why I pushed for allowing external
> nominations).
>
> Historically, the only reason to become a core committer was to commit
> code. Some of us no doubt desired or demonstrated greater influence, but
> all of us have committed code or reviewed and merged PRs, either
> directly to CPython or one of the related projects.
>
> This is not a job for everyone, but it's been the only job we had on offer.
>
> The closest alternative job was to be elected to the board of the Python
> Software Foundation. But this is still not a job for everyone. They also
> are not considered core committers, despite making significant
> contributions.
>
> We now have a new job on offer. Exactly what that job involves isn't
> quite defined yet, but it will certainly include some amount of
> project/program/process management, likely some customer/user engagement
> (or relationship management, if you prefer), and potentially some
> independent decision making.
>
> Guido is the only core developer who has previously contributed to
> Python in this way (whatever "this way" turns out to mean). The rest of
> us happily worked under "someone else" doing it.
>
> Meanwhile, many non-core committers in the Python community have spent
> their time building companies, consulting businesses or educational
> courses. Spending time writing code and reviewing PRs is not how they
> want to contribute, and so they have contributed in other ways -
> including writing and often reviewing PEPs. There was no need for them
> to be a core committer, since they weren't doing any of the
> committer-specific tasks.
>
> In the PEP 8016 discussions (pre vote), we agreed that if we chose to
> elect someone who is not currently a core developer, we would also
> probably vote to make them a core developer, so there is no harm in
> allowing externals to be nominated. Also since the core committers are
> voluntarily submitting to their guidance, it makes sense that voting to
> elect/dissolve is restricted to us.
>
> In summary, members of the Steering Council are filling a new role with
> only one explicit precedent within the core committers. The
> qualifications are different, and so the pool of candidates is
> different. The existing core committers will submit to the Steering
> Council, and so are the ones who elect them.
>
> (Note that I've carefully used "core committer" and "core developer"
> above. I believe it's very important to distinguish between "write
> access on GitHub" and "project decision maker", and no reason to force
> an arbitrary overlap.)
>
> Cheers,
> Steve
>


-- 
Keeping medicines from the bloodstreams of the sick; food
from the bellies of the hungry; books from the hands of the
uneducated; technology from the underdeveloped; and putting
advocates of freedom in prisons.  Intellectual property is
to the 21st century what the slave trade was to the 16th.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.python.org/pipermail/python-dev/attachments/20190104/30ae92e5/attachment.html>

From solipsis at pitrou.net  Fri Jan  4 15:36:05 2019
From: solipsis at pitrou.net (Antoine Pitrou)
Date: Fri, 4 Jan 2019 21:36:05 +0100
Subject: [Python-Dev] Interested in serving on Steering Council
In-Reply-To: <CAEbHw4b-dWKeYWaYoGBS1HMxJjuN0gquM99mKfuNvvU3wmwzGQ@mail.gmail.com>
References: <CAEbHw4bhjt3k-Q57BnSWw150B2Pint1465ick+775i-eaYeVBA@mail.gmail.com>
 <20190102191517.7fc2094c@fsol>
 <cb08756a-cf4b-f6ad-5147-7ef3e41f4c95@python.org>
 <CAEbHw4b-dWKeYWaYoGBS1HMxJjuN0gquM99mKfuNvvU3wmwzGQ@mail.gmail.com>
Message-ID: <20190104213605.57fba25b@fsol>


Hi David,

On Fri, 4 Jan 2019 15:24:20 -0500
David Mertz <mertz at gnosis.cx> wrote:
> 
> I've been part of the Python community since 1998, but really active in it
> since about 2001.  During the early 2000s, I wrote a large number of widely
> read articles promoting Python, often delving into explaining semi-obscure
> features and language design issues.  Most of these were with in my column
> _Charming Python_.  I believe that several changes in Python itself?such as
> making coroutines easier to use and the design of metaclasses and class
> decorators?were significantly influenced by things I wrote on the topics.
> [snip]

Those are useful things to know, thank you.

> If the core developers feel that the overwhelming qualification for the
> Steering Committee is familiarity with the C code base of CPython, then
> indeed I am not the best candidate for that.

Obviously not the overwhelming qualification (though at least _some_ of
the committee members would have to be familiar with the C code base, I
think).

> If language design issues are
> more important?and especially if thinking about Python's place among users
> and industry are important, then I think I'm a very good candidate for the
> role.

That, but I think also familiarity with the development and
contribution process, will definitely play a role.  In other words, if
some external candidate gets elected I would hope they take the time to
become familiar with how things work in that regard, and try to
contribute themselves (not necessarily to make important contributions
to the codebase but to understand the daily routine).

Regards

Antoine.

From alexander.belopolsky at gmail.com  Sat Jan  5 03:55:44 2019
From: alexander.belopolsky at gmail.com (Alexander Belopolsky)
Date: Sat, 5 Jan 2019 11:55:44 +0300
Subject: [Python-Dev] Return type of datetime subclasses added to
 timedelta
In-Reply-To: <1059740e-cc65-205d-5986-a9397463a315@ganssle.io>
References: <1059740e-cc65-205d-5986-a9397463a315@ganssle.io>
Message-ID: <CAP7h-xa-Dp8TXrm7Oa=jDwf0wyBfVy-6zK08w219q0jVaYACiQ@mail.gmail.com>

On Wed, Jan 2, 2019 at 10:18 PM Paul Ganssle <paul at ganssle.io> wrote:

> .. the original objection was that this implementation assumes that the
> datetime subclass has a constructor with the same (or a sufficiently
> similar) signature as datetime.
>
While this was used as a possible rationale for the way standard types
behave, the main objection to changing datetime classes is that it will
make them behave differently from builtins.  For example:

>>> class F(float):
...     pass
...
>>> type(F.fromhex('AA'))
<class '__main__.F'>
>>> type(F(1) + F(2))
<class 'float'>

This may be a legitimate gripe, but unfortunately that ship has sailed long
> ago. All of datetime's alternate constructors make this assumption. Any
> subclass that does not meet this requirement must have worked around it
> long ago (or they don't care about alternate constructors).
>

This is right, but the same argument is equally applicable to int, float,
etc. subclasses.  If you want to limit your change to datetime types you
should explain what makes these types special.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.python.org/pipermail/python-dev/attachments/20190105/2b3720ca/attachment.html>

From pmiscml at gmail.com  Sun Jan  6 06:10:48 2019
From: pmiscml at gmail.com (Paul Sokolovsky)
Date: Sun, 6 Jan 2019 13:10:48 +0200
Subject: [Python-Dev] Compilation of "except FooExc as var" adds useless
 store
Message-ID: <20190106131048.6e0a3dd8@x230>

Hello,

As explained in
https://docs.python.org/3/reference/compound_stmts.html#the-try-statement ,

except E as N:
    foo

is actually compiled as:

except E as N:
    try:
        foo
    finally:
        del N

But looking at the generated bytecode, it's worse than that:

             16 STORE_NAME               1 (N)
             18 POP_TOP
             20 SETUP_FINALLY            8 (to 30)

  4          22 LOAD_NAME                2 (foo)
             24 POP_TOP
             26 POP_BLOCK
             28 LOAD_CONST               0 (None)
        >>   30 LOAD_CONST               0 (None)
             32 STORE_NAME               1 (N)
             34 DELETE_NAME              1 (N)
             36 END_FINALLY


It's clear that what happens there is that first None is stored to N,
just to del it as the next step. Indeed, that's what done in the
compile.c:

https://github.com/python/cpython/blob/master/Python/compile.c#L2905

Storing None looks superfluous. For example, DELETE_FAST explicitly
stores NULL on delete.
https://github.com/python/cpython/blob/master/Python/ceval.c#L2249 

Likewise, for DELETE_NAME/DELETE_GLOBAL, PyObject_DelItem() is
called which translates to:

m->mp_ass_subscript(o, key, (PyObject*)NULL);

So hopefully any compliant mapping implementation actually clears
stored value, not leaving it dangling.

The "store None" behavior can be traced down to introduction of the
"del except target var" behavior back in 2007:
https://github.com/python/cpython/commit/b940e113bf90ff71b0ef57414ea2beea9d2a4bc0#diff-cb296cc5109f5640ff3f6d7198a6abeeR1999

There's no clear explanation why it's done like that, so probably an
artifact of the initial implementation. Note that even
https://github.com/python/cpython/commit/520b7ae27e39d1c77ea74ccd1b184d7cb43f9dcb
which did quite a bunch of refactoring to "except" implementation, and
reformatted this code, otherwise left it in place.

P.S.
I actually wanted to argue that such an implementation is hardly ideal
at all. Consider:

----
e = "my precious data"

try:
    1/0
except Exception as e:
    pass

# Where's my *global* variable?
# Worse, my variable can be gone or not, depending on whether exception
# triggered or not.
print(e)
----

So, perhaps the change should be not removing "e = None" part, but
conversely, removing the "del e" part.


-- 
Best regards,
 Paul                          mailto:pmiscml at gmail.com

From rosuav at gmail.com  Sun Jan  6 06:19:39 2019
From: rosuav at gmail.com (Chris Angelico)
Date: Sun, 6 Jan 2019 22:19:39 +1100
Subject: [Python-Dev] Compilation of "except FooExc as var" adds useless
 store
In-Reply-To: <20190106131048.6e0a3dd8@x230>
References: <20190106131048.6e0a3dd8@x230>
Message-ID: <CAPTjJmqhK24uFSpbQTe3qUhDU_tO+ENhw2psXj0g5XDg+2wgOg@mail.gmail.com>

On Sun, Jan 6, 2019 at 10:12 PM Paul Sokolovsky <pmiscml at gmail.com> wrote:
> It's clear that what happens there is that first None is stored to N,
> just to del it as the next step. Indeed, that's what done in the
> compile.c:
>
> https://github.com/python/cpython/blob/master/Python/compile.c#L2905
>
> Storing None looks superfluous.
>
> There's no clear explanation why it's done like that, so probably an
> artifact of the initial implementation.

With something as clearly deliberate as this, it's generally safe to
assume there's a good reason for it. But I would very much like to see
that reason documented, preferably with an example of something that
could otherwise fail.

> P.S.
> I actually wanted to argue that such an implementation is hardly ideal
> at all. Consider:
>
> ----
> e = "my precious data"
>
> try:
>     1/0
> except Exception as e:
>     pass
>
> # Where's my *global* variable?
> # Worse, my variable can be gone or not, depending on whether exception
> # triggered or not.
> print(e)
> ----
>
> So, perhaps the change should be not removing "e = None" part, but
> conversely, removing the "del e" part.

No, there's a good reason for having the "del e", and that's to
prevent reference loops (since the exception includes the full
traceback, including all local variables). However, I would argue -
and HAVE argued - that this would be a perfect situation for an inner
scope, where the inner variable "e" is actually shadowing, rather than
overwriting, your outer "e". But the push-back against *that* proposal
was insane.

ChrisA

From pmiscml at gmail.com  Sun Jan  6 06:40:43 2019
From: pmiscml at gmail.com (Paul Sokolovsky)
Date: Sun, 6 Jan 2019 13:40:43 +0200
Subject: [Python-Dev] Compilation of "except FooExc as var" adds useless
 store
In-Reply-To: <CAPTjJmqhK24uFSpbQTe3qUhDU_tO+ENhw2psXj0g5XDg+2wgOg@mail.gmail.com>
References: <20190106131048.6e0a3dd8@x230>
 <CAPTjJmqhK24uFSpbQTe3qUhDU_tO+ENhw2psXj0g5XDg+2wgOg@mail.gmail.com>
Message-ID: <20190106134043.54b6d12c@x230>

Hello,

On Sun, 6 Jan 2019 22:19:39 +1100
Chris Angelico <rosuav at gmail.com> wrote:

> > It's clear that what happens there is that first None is stored to
> > N, just to del it as the next step. Indeed, that's what done in the
> > compile.c:
> >
> > https://github.com/python/cpython/blob/master/Python/compile.c#L2905
> >
> > Storing None looks superfluous.
> >
> > There's no clear explanation why it's done like that, so probably an
> > artifact of the initial implementation.  
> 
> With something as clearly deliberate as this, it's generally safe to
> assume there's a good reason for it.

Absolutely, and one doesn't need to look far for an example. For 20
years Python was devoid of ":=", then, suddenly... ;-).

> But I would very much like to see
> that reason documented, preferably with an example of something that
> could otherwise fail.

Yeah, I'm keen to know too!

[]

> > So, perhaps the change should be not removing "e = None" part, but
> > conversely, removing the "del e" part.  
> 
> No, there's a good reason for having the "del e", and that's to
> prevent reference loops 

So, I'm not sure if I made that clear, but the issue is that currently
the generated code tries to break the reference loop *twice*. But once
should be enough. And which one of "N = None" or "del N" is better is
something to consider.

-- 
Best regards,
 Paul                          mailto:pmiscml at gmail.com

From steve at pearwood.info  Sun Jan  6 07:10:24 2019
From: steve at pearwood.info (Steven D'Aprano)
Date: Sun, 6 Jan 2019 23:10:24 +1100
Subject: [Python-Dev] Compilation of "except FooExc as var" adds useless
 store
In-Reply-To: <20190106131048.6e0a3dd8@x230>
References: <20190106131048.6e0a3dd8@x230>
Message-ID: <20190106121011.GX13616@ando.pearwood.info>

On Sun, Jan 06, 2019 at 01:10:48PM +0200, Paul Sokolovsky wrote:

[...]
> P.S.
> I actually wanted to argue that such an implementation is hardly ideal
> at all. Consider:
> 
> ----
> e = "my precious data"
> try:
>     1/0
> except Exception as e:
>     pass
> 
> # Where's my *global* variable?
> # Worse, my variable can be gone or not, depending on whether exception
> # triggered or not.
> print(e)

That's not "worse", that's BETTER.

With e deleted, you get an immediate exception the moment you try to use 
it, and you *know* something has gone wrong, instead of the program 
continuing, either to fail much later, where it isn't clear why the code 
fails, or worse, not fail at all, but instead silently do the wrong 
thing.

Incorrect code that fails sooner is better than incorrect code that 
fails later, and MUCH better than incorrect code that doesn't fail at 
all.

The real problem here is that if e holds your precious data, why are you 
assigning an exception to e? You probably wouldn't complain that this 
breaks your program:

e = "my precious data"
import sys as e
# where is my data???

or this:

e = "my precious data"
e = None

so why do you expect `except Exception as e` to be different? Its just a 
name binding operation, the same as all the others.

Regardless of the mechanism, if you don't want to lose your precious 
data, then don't use the same name. But if you truly, really must 
overwrite e, then there is a simple work-around:

e = "my precious data"
try:
    1/0
except Exception as err:
    e = err


Having the exception name unbound at the end of the block is a weird and 
unfortunate wart on the language, but not as unfortunate as having 
exceptions cause long-lasting reference cycles.


-- 
Steve

From pmiscml at gmail.com  Sun Jan  6 08:03:03 2019
From: pmiscml at gmail.com (Paul Sokolovsky)
Date: Sun, 6 Jan 2019 15:03:03 +0200
Subject: [Python-Dev] Compilation of "except FooExc as var" adds useless
 store
In-Reply-To: <20190106121011.GX13616@ando.pearwood.info>
References: <20190106131048.6e0a3dd8@x230>
 <20190106121011.GX13616@ando.pearwood.info>
Message-ID: <20190106150303.57b77c5a@x230>

Hello,

On Sun, 6 Jan 2019 23:10:24 +1100
Steven D'Aprano <steve at pearwood.info> wrote:

[]

> > # Where's my *global* variable?
> > # Worse, my variable can be gone or not, depending on whether
> > exception # triggered or not.
> > print(e)  
> 
> That's not "worse", that's BETTER.
> 
> With e deleted, you get an immediate exception the moment you try to
> use it, and you *know* something has gone wrong

Ack. Such an explanation makes sense, though semantics behind it is
"magic". And given that variable deletion happens conditionally on
whether exception happened or not, it's still pretty strange. I would
definitely find a behavior of merely clearing an "except" target
variable to be more understandable than magic fiddling with namespaces.

[]

> The real problem here is that if e holds your precious data, why are
> you assigning an exception to e?

Because I got an idea that "except Exc as var" introduces a nested
lexical scope for "var"? I.e., a completely new variable is introduced,
which may shadow, but not override, any on the enclosing scope.

Why would I get that idea? Well, because lexical scoping is a
well-known concept in many programming languages, Python included. For
example, list/set/etc. comprehensions have proper lexical scope, how
would I imagine that specifically in except clauses, it's not a proper
lexical scoping, but a leaky "emulation" of it? 

That said, the description in
https://docs.python.org/3/reference/compound_stmts.html#the-try-statement
doesn't give any false promises regarding lexical scoping. Instead, it
effectively says that the behavior is CPython implementation detail:

"Exceptions are cleared because with the traceback attached to them,
they form a reference cycle"


So, the only thing to take away from this might be indeed an opportunity
to save 4 bytes of bytecode/2 dispatches.

> Having the exception name unbound at the end of the block is a weird
> and unfortunate wart on the language, but not as unfortunate as
> having exceptions cause long-lasting reference cycles.

Thanks, that summarizes it well. And well, my interest is also how
non-compliant would be for another Python implementation to act
differently, specifically to skip wrapping an except handler body in
try-finally (i.e., go back to Python2 behavior). I'm keen to add such
an option to my fork of MicroPython.

> 
> 
> -- 
> Steve

[]

-- 
Best regards,
 Paul                          mailto:pmiscml at gmail.com

From steve at pearwood.info  Sun Jan  6 09:14:55 2019
From: steve at pearwood.info (Steven D'Aprano)
Date: Mon, 7 Jan 2019 01:14:55 +1100
Subject: [Python-Dev] Compilation of "except FooExc as var" adds useless
 store
In-Reply-To: <20190106150303.57b77c5a@x230>
References: <20190106131048.6e0a3dd8@x230>
 <20190106121011.GX13616@ando.pearwood.info> <20190106150303.57b77c5a@x230>
Message-ID: <20190106141453.GY13616@ando.pearwood.info>

On Sun, Jan 06, 2019 at 03:03:03PM +0200, Paul Sokolovsky wrote:

[...]
> Ack. Such an explanation makes sense, though semantics behind it is
> "magic". And given that variable deletion happens conditionally on
> whether exception happened or not, it's still pretty strange.

I don't think anyone *likes* the current behaviour. Speaking for myself, 
I think it is definitely a wart on the language, but a justifiable one, 
since the alternative is worse.

So yes, it is strange, and is something that Python programmers have to 
learn. Probably through experience.


> I would
> definitely find a behavior of merely clearing an "except" target
> variable to be more understandable than magic fiddling with namespaces.

I don't understand what this means. What is "clearing an except target"? 
Do you mean deleting the target name? Names are either bound to an 
object, or they aren't bound at all, so I don't know what it means to 
"clear" a name if it doesn't mean delete it.


> []
> 
> > The real problem here is that if e holds your precious data, why are
> > you assigning an exception to e?
> 
> Because I got an idea that "except Exc as var" introduces a nested
> lexical scope for "var"? I.e., a completely new variable is introduced,
> which may shadow, but not override, any on the enclosing scope.
> 
> Why would I get that idea? Well, because lexical scoping is a
> well-known concept in many programming languages, Python included. For
> example, list/set/etc. comprehensions have proper lexical scope, how
> would I imagine that specifically in except clauses, it's not a proper
> lexical scoping, but a leaky "emulation" of it? 

It isn't an emulation of lexical scope at all. Only the exception target 
is deleted, not other variables bound inside the block.

But a better question is, why would you (generic, not you personally) 
imagine that, alone out of all flow control statements, ONLY "except" 
clauses introduce a new scope? Every other flow control statement (for, 
while, if, elif, else, try, with) runs in the current scope. The only 
statements which create a new scope are def and class. (Did I miss any?)


[...]
> Thanks, that summarizes it well. And well, my interest is also how
> non-compliant would be for another Python implementation to act
> differently, specifically to skip wrapping an except handler body in
> try-finally (i.e., go back to Python2 behavior). I'm keen to add such
> an option to my fork of MicroPython.

Wouldn't that mean that MicroPython suffers from the exception/traceback 
reference cycle problem? How do you propose to solve that?



-- 
Steve

From rosuav at gmail.com  Sun Jan  6 09:44:23 2019
From: rosuav at gmail.com (Chris Angelico)
Date: Mon, 7 Jan 2019 01:44:23 +1100
Subject: [Python-Dev] Compilation of "except FooExc as var" adds useless
 store
In-Reply-To: <20190106141453.GY13616@ando.pearwood.info>
References: <20190106131048.6e0a3dd8@x230>
 <20190106121011.GX13616@ando.pearwood.info>
 <20190106150303.57b77c5a@x230> <20190106141453.GY13616@ando.pearwood.info>
Message-ID: <CAPTjJmrTe_dqaiho+TAiyBvGXQ+mNSg2AQOvEx6=4rk=7qi-Mw@mail.gmail.com>

On Mon, Jan 7, 2019 at 1:21 AM Steven D'Aprano <steve at pearwood.info> wrote:
> > I would
> > definitely find a behavior of merely clearing an "except" target
> > variable to be more understandable than magic fiddling with namespaces.
>
> I don't understand what this means. What is "clearing an except target"?
> Do you mean deleting the target name? Names are either bound to an
> object, or they aren't bound at all, so I don't know what it means to
> "clear" a name if it doesn't mean delete it.

Setting it to None before unbinding it. It's apparently not enough to
say "del e" - you have to do "e = None; del e". Check the OP.

ChrisA

From storchaka at gmail.com  Sun Jan  6 10:26:09 2019
From: storchaka at gmail.com (Serhiy Storchaka)
Date: Sun, 6 Jan 2019 17:26:09 +0200
Subject: [Python-Dev] Compilation of "except FooExc as var" adds useless
 store
In-Reply-To: <20190106131048.6e0a3dd8@x230>
References: <20190106131048.6e0a3dd8@x230>
Message-ID: <q0t6id$a79$1@blaine.gmane.org>

06.01.19 13:10, Paul Sokolovsky ????:
> Storing None looks superfluous. For example, DELETE_FAST explicitly
> stores NULL on delete.
> https://github.com/python/cpython/blob/master/Python/ceval.c#L2249
> 
> Likewise, for DELETE_NAME/DELETE_GLOBAL, PyObject_DelItem() is
> called which translates to:
> 
> m->mp_ass_subscript(o, key, (PyObject*)NULL);
> 
> So hopefully any compliant mapping implementation actually clears
> stored value, not leaving it dangling.
> 
> The "store None" behavior can be traced down to introduction of the
> "del except target var" behavior back in 2007:
> https://github.com/python/cpython/commit/b940e113bf90ff71b0ef57414ea2beea9d2a4bc0#diff-cb296cc5109f5640ff3f6d7198a6abeeR1999
> 
> There's no clear explanation why it's done like that, so probably an
> artifact of the initial implementation. Note that even
> https://github.com/python/cpython/commit/520b7ae27e39d1c77ea74ccd1b184d7cb43f9dcb
> which did quite a bunch of refactoring to "except" implementation, and
> reformatted this code, otherwise left it in place.

Because there is a reason for such code.

See issue1631942 [1] and the thread with the subject "self-contained 
exceptions" on the Python-3000 mailing list [2] for the rationale.

In short, the code

     try:
         1/0
     except Exception as e:
         del e

should work.

I do not see a problem with storing None before deleting a variable. 
This is not a performance critical code, because it is executed only 
when an exception was raised and caught.

[1] https://bugs.python.org/issue1631942
[2] https://mail.python.org/pipermail/python-3000/2007-January/005294.html


From paul at ganssle.io  Sun Jan  6 10:32:11 2019
From: paul at ganssle.io (Paul Ganssle)
Date: Sun, 6 Jan 2019 10:32:11 -0500
Subject: [Python-Dev] Compilation of "except FooExc as var" adds useless
 store
In-Reply-To: <20190106141453.GY13616@ando.pearwood.info>
References: <20190106131048.6e0a3dd8@x230>
 <20190106121011.GX13616@ando.pearwood.info> <20190106150303.57b77c5a@x230>
 <20190106141453.GY13616@ando.pearwood.info>
Message-ID: <4d012c3d-fc57-3fdc-1721-18f5384e20e3@ganssle.io>

On 1/6/19 9:14 AM, Steven D'Aprano wrote:
> [...]
> But a better question is, why would you (generic, not you personally) 
> imagine that, alone out of all flow control statements, ONLY "except" 
> clauses introduce a new scope? Every other flow control statement (for, 
> while, if, elif, else, try, with) runs in the current scope. The only 
> statements which create a new scope are def and class. (Did I miss any?)

To be fair except is already unique in that it /does/ "pseudo-scope" the
binding to the variable. The other obvious comparisons are to for loops
and context managers, both of which bind a value to a name that survives
after the exit of the control flow statement.

Given the reference counting reasons for exceptions *not* to outlive
their control flow statement, they are the "odd man out" in that they
delete the exception after the control statement's body exits. To me,
the natural and intuitive way to do this would be to have the exception
live in its own scope where it shadows existing variables, rather than
replacing and then completely removing them. The way it works now is
halfway between the behavior of existing control flow statements and
having a proper nested scope.

Not saying that anything has to change - in the end this is one of the
more minor "gotchas" about Python, and there may be practical reasons
for leaving it as it is - but I do think it's worth noting that for many
people this /will/ be surprising behavior, even if you know that
exceptions don't survive outside of the "except" block.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.python.org/pipermail/python-dev/attachments/20190106/69d9425d/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: OpenPGP digital signature
URL: <http://mail.python.org/pipermail/python-dev/attachments/20190106/69d9425d/attachment-0001.sig>

From rosuav at gmail.com  Sun Jan  6 10:35:37 2019
From: rosuav at gmail.com (Chris Angelico)
Date: Mon, 7 Jan 2019 02:35:37 +1100
Subject: [Python-Dev] Compilation of "except FooExc as var" adds useless
 store
In-Reply-To: <q0t6id$a79$1@blaine.gmane.org>
References: <20190106131048.6e0a3dd8@x230> <q0t6id$a79$1@blaine.gmane.org>
Message-ID: <CAPTjJmoUbOH_8CRaUeUQ2mKBQPH_29WRZBrxidaOkYfT6Jt+2Q@mail.gmail.com>

On Mon, Jan 7, 2019 at 2:27 AM Serhiy Storchaka <storchaka at gmail.com> wrote:
> > The "store None" behavior can be traced down to introduction of the
> > "del except target var" behavior back in 2007:
> > https://github.com/python/cpython/commit/b940e113bf90ff71b0ef57414ea2beea9d2a4bc0#diff-cb296cc5109f5640ff3f6d7198a6abeeR1999
> >
> > There's no clear explanation why it's done like that, so probably an
> > artifact of the initial implementation. Note that even
> > https://github.com/python/cpython/commit/520b7ae27e39d1c77ea74ccd1b184d7cb43f9dcb
> > which did quite a bunch of refactoring to "except" implementation, and
> > reformatted this code, otherwise left it in place.
>
> Because there is a reason for such code.

What reason though??

> See issue1631942 [1] and the thread with the subject "self-contained
> exceptions" on the Python-3000 mailing list [2] for the rationale.
>
> In short, the code
>
>      try:
>          1/0
>      except Exception as e:
>          del e
>
> should work.

But obviously not, because the code was specifically written to set it
to None first. It's not the sort of thing that can be done
accidentally, is it?

ChrisA

From storchaka at gmail.com  Sun Jan  6 10:50:46 2019
From: storchaka at gmail.com (Serhiy Storchaka)
Date: Sun, 6 Jan 2019 17:50:46 +0200
Subject: [Python-Dev] Compilation of "except FooExc as var" adds useless
 store
In-Reply-To: <CAPTjJmoUbOH_8CRaUeUQ2mKBQPH_29WRZBrxidaOkYfT6Jt+2Q@mail.gmail.com>
References: <20190106131048.6e0a3dd8@x230> <q0t6id$a79$1@blaine.gmane.org>
 <CAPTjJmoUbOH_8CRaUeUQ2mKBQPH_29WRZBrxidaOkYfT6Jt+2Q@mail.gmail.com>
Message-ID: <q0t80n$m9u$1@blaine.gmane.org>

06.01.19 17:35, Chris Angelico ????:
> On Mon, Jan 7, 2019 at 2:27 AM Serhiy Storchaka <storchaka at gmail.com> wrote:
>> Because there is a reason for such code.
> 
> What reason though??

I added references and excerpts in the previous message.

>> In short, the code
>>
>>       try:
>>           1/0
>>       except Exception as e:
>>           del e
>>
>> should work.
> 
> But obviously not, because the code was specifically written to set it
> to None first.
Did you tried it? It works.


From paul at ganssle.io  Sun Jan  6 11:02:43 2019
From: paul at ganssle.io (Paul Ganssle)
Date: Sun, 6 Jan 2019 11:02:43 -0500
Subject: [Python-Dev] Return type of datetime subclasses added to
 timedelta
In-Reply-To: <CAP7h-xa-Dp8TXrm7Oa=jDwf0wyBfVy-6zK08w219q0jVaYACiQ@mail.gmail.com>
References: <1059740e-cc65-205d-5986-a9397463a315@ganssle.io>
 <CAP7h-xa-Dp8TXrm7Oa=jDwf0wyBfVy-6zK08w219q0jVaYACiQ@mail.gmail.com>
Message-ID: <bb5120e0-159e-106d-04c6-2a15f7398966@ganssle.io>

I can think of many reasons why datetime is different from builtins,
though to be honest I'm not sure that consistency for its own sake is
really a strong argument for keeping a counter-intuitive behavior - and
to be honest I'm open to the idea that /all/ arithmetic types /should/
have some form of this change.

That said, I would say that the biggest difference between datetime and
builtins (other than the fact that datetime is /not/ a builtin, and as
such doesn't necessarily need to be categorized in this group), is that
unlike almost all other arithmetic types, /datetime/ has a special,
dedicated type for describing differences in datetimes. Using your
example of a float subclass, consider that without the behavior of
"addition of floats returns floats", it would be hard to predict what
would happen in this situation:

>>> F(1.2) + 3.4

Would that always return a float, even though F(1.2) + F(3.4) returns an
F? Would that return an F because F is the left-hand operand? Would it
return a float because float is the right-hand operand? Would you walk
the MROs and find the lowest type in common between the operands and
return that? It's not entirely clear which subtype predominates. With
datetime, you have:

datetime - datetime -> timedelta
datetime ? timedelta -> datetime
timedelta ? timedelta -> timedelta

There's no operation between two datetime objects that would return a
datetime object, so it's always clear: operations between datetime
subclasses return timedelta, operations between a datetime object and a
timedelta return the subclass of the datetime that it was added to or
subtracted from.

Of course, the real way to resolve whether datetime should be different
from int/float/string/etc is to look at why this choice was actually
made for those types in the first place, and decide whether datetime is
like them /in this respect/. The heterogeneous operations problem may be
a reasonable justification for leaving the other builtins alone but
changing datetime, but if someone knows of other fundamental reasons why
the decision to have arithmetic operations always create the base class
was chosen, please let me know.

Best,
Paul

On 1/5/19 3:55 AM, Alexander Belopolsky wrote:
>
>
> On Wed, Jan 2, 2019 at 10:18 PM Paul Ganssle <paul at ganssle.io
> <mailto:paul at ganssle.io>> wrote:
>
>     .. the original objection was that this implementation assumes
>     that the datetime subclass has a constructor with the same (or a
>     sufficiently similar) signature as datetime.
>
> While this was used as a possible rationale for the way standard types
> behave, the main objection to changing datetime classes is that it
> will make them behave differently from builtins.? For example:
>
> >>> class F(float):
> ...? ? ?pass
> ...
> >>> type(F.fromhex('AA'))
> <class '__main__.F'>
> >>> type(F(1) + F(2))
> <class 'float'>
>
>     This may be a legitimate gripe, but unfortunately that ship has
>     sailed long ago. All of datetime's alternate constructors make
>     this assumption. Any subclass that does not meet this requirement
>     must have worked around it long ago (or they don't care about
>     alternate constructors).
>
>
> This is right, but the same argument is equally applicable to int,
> float, etc. subclasses.? If you want to limit your change to datetime
> types you should explain what makes these types special.??
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.python.org/pipermail/python-dev/attachments/20190106/8f7a75a7/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: OpenPGP digital signature
URL: <http://mail.python.org/pipermail/python-dev/attachments/20190106/8f7a75a7/attachment.sig>

From rosuav at gmail.com  Sun Jan  6 11:05:27 2019
From: rosuav at gmail.com (Chris Angelico)
Date: Mon, 7 Jan 2019 03:05:27 +1100
Subject: [Python-Dev] Compilation of "except FooExc as var" adds useless
 store
In-Reply-To: <q0t80n$m9u$1@blaine.gmane.org>
References: <20190106131048.6e0a3dd8@x230> <q0t6id$a79$1@blaine.gmane.org>
 <CAPTjJmoUbOH_8CRaUeUQ2mKBQPH_29WRZBrxidaOkYfT6Jt+2Q@mail.gmail.com>
 <q0t80n$m9u$1@blaine.gmane.org>
Message-ID: <CAPTjJmr7EvUemFakEMto8fCO_5AbaW-ebqNbqQq3U=BJ3Xkqdg@mail.gmail.com>

On Mon, Jan 7, 2019 at 2:52 AM Serhiy Storchaka <storchaka at gmail.com> wrote:
>
> 06.01.19 17:35, Chris Angelico ????:
> > On Mon, Jan 7, 2019 at 2:27 AM Serhiy Storchaka <storchaka at gmail.com> wrote:
> >> Because there is a reason for such code.
> >
> > What reason though??
>
> I added references and excerpts in the previous message.

Which I read, and they do not explain the assignment of None. The only
reference is that the tracker issue mentions having a test case to
ensure that it's happening, which is further proof that it's
intentional, but still fails to explain *why*.

ChrisA

From paul at ganssle.io  Sun Jan  6 11:11:42 2019
From: paul at ganssle.io (Paul G)
Date: Sun, 06 Jan 2019 16:11:42 +0000
Subject: [Python-Dev] Compilation of "except FooExc as var" adds useless
 store
In-Reply-To: <CAPTjJmr7EvUemFakEMto8fCO_5AbaW-ebqNbqQq3U=BJ3Xkqdg@mail.gmail.com>
References: <20190106131048.6e0a3dd8@x230> <q0t6id$a79$1@blaine.gmane.org>
 <CAPTjJmoUbOH_8CRaUeUQ2mKBQPH_29WRZBrxidaOkYfT6Jt+2Q@mail.gmail.com>
 <q0t80n$m9u$1@blaine.gmane.org>
 <CAPTjJmr7EvUemFakEMto8fCO_5AbaW-ebqNbqQq3U=BJ3Xkqdg@mail.gmail.com>
Message-ID: <5B21C86E-F904-44E8-BC8D-9E17BB31A9F0@ganssle.io>

I think Serhiy is saying that if you delete exc before the except body ends, when the compiled code goes to delete it it will fail. Binding to None guarantees that there is something to delete.

On January 6, 2019 4:05:27 PM UTC, Chris Angelico <rosuav at gmail.com> wrote:
>On Mon, Jan 7, 2019 at 2:52 AM Serhiy Storchaka <storchaka at gmail.com>
>wrote:
>>
>> 06.01.19 17:35, Chris Angelico ????:
>> > On Mon, Jan 7, 2019 at 2:27 AM Serhiy Storchaka
><storchaka at gmail.com> wrote:
>> >> Because there is a reason for such code.
>> >
>> > What reason though??
>>
>> I added references and excerpts in the previous message.
>
>Which I read, and they do not explain the assignment of None. The only
>reference is that the tracker issue mentions having a test case to
>ensure that it's happening, which is further proof that it's
>intentional, but still fails to explain *why*.
>
>ChrisA
>_______________________________________________
>Python-Dev mailing list
>Python-Dev at python.org
>https://mail.python.org/mailman/listinfo/python-dev
>Unsubscribe:
>https://mail.python.org/mailman/options/python-dev/paul%40ganssle.io
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.python.org/pipermail/python-dev/attachments/20190106/fd150079/attachment.html>

From rosuav at gmail.com  Sun Jan  6 11:18:00 2019
From: rosuav at gmail.com (Chris Angelico)
Date: Mon, 7 Jan 2019 03:18:00 +1100
Subject: [Python-Dev] Compilation of "except FooExc as var" adds useless
 store
In-Reply-To: <5B21C86E-F904-44E8-BC8D-9E17BB31A9F0@ganssle.io>
References: <20190106131048.6e0a3dd8@x230> <q0t6id$a79$1@blaine.gmane.org>
 <CAPTjJmoUbOH_8CRaUeUQ2mKBQPH_29WRZBrxidaOkYfT6Jt+2Q@mail.gmail.com>
 <q0t80n$m9u$1@blaine.gmane.org>
 <CAPTjJmr7EvUemFakEMto8fCO_5AbaW-ebqNbqQq3U=BJ3Xkqdg@mail.gmail.com>
 <5B21C86E-F904-44E8-BC8D-9E17BB31A9F0@ganssle.io>
Message-ID: <CAPTjJmpsz_+0teVETV6YzZzMZ18rjtA1tVStCGoYxPzZs1jhCg@mail.gmail.com>

On Mon, Jan 7, 2019 at 3:13 AM Paul G <paul at ganssle.io> wrote:
>
> I think Serhiy is saying that if you delete exc before the except body ends, when the compiled code goes to delete it it will fail. Binding to None guarantees that there is something to delete.

Ahh! Thank you. I interpreted that example as a "this is what it
compiles to", rather than actual source code that might fail. Can we
get this example, suitably annotated, into the documentation
somewhere?

ChrisA

From paul at ganssle.io  Sun Jan  6 11:37:34 2019
From: paul at ganssle.io (Paul G)
Date: Sun, 06 Jan 2019 16:37:34 +0000
Subject: [Python-Dev] Compilation of "except FooExc as var" adds useless
 store
In-Reply-To: <CAPTjJmpsz_+0teVETV6YzZzMZ18rjtA1tVStCGoYxPzZs1jhCg@mail.gmail.com>
References: <20190106131048.6e0a3dd8@x230> <q0t6id$a79$1@blaine.gmane.org>
 <CAPTjJmoUbOH_8CRaUeUQ2mKBQPH_29WRZBrxidaOkYfT6Jt+2Q@mail.gmail.com>
 <q0t80n$m9u$1@blaine.gmane.org>
 <CAPTjJmr7EvUemFakEMto8fCO_5AbaW-ebqNbqQq3U=BJ3Xkqdg@mail.gmail.com>
 <5B21C86E-F904-44E8-BC8D-9E17BB31A9F0@ganssle.io>
 <CAPTjJmpsz_+0teVETV6YzZzMZ18rjtA1tVStCGoYxPzZs1jhCg@mail.gmail.com>
Message-ID: <2457F573-1F15-4312-BBFF-0CB96452FC88@ganssle.io>

I am not familiar enough with the compiler logic, but would it be possible to optimize this away by detecting whether the bound name has already been deleted during the body of the except statement?


On January 6, 2019 4:18:00 PM UTC, Chris Angelico <rosuav at gmail.com> wrote:
>On Mon, Jan 7, 2019 at 3:13 AM Paul G <paul at ganssle.io> wrote:
>>
>> I think Serhiy is saying that if you delete exc before the except
>body ends, when the compiled code goes to delete it it will fail.
>Binding to None guarantees that there is something to delete.
>
>Ahh! Thank you. I interpreted that example as a "this is what it
>compiles to", rather than actual source code that might fail. Can we
>get this example, suitably annotated, into the documentation
>somewhere?
>
>ChrisA
>_______________________________________________
>Python-Dev mailing list
>Python-Dev at python.org
>https://mail.python.org/mailman/listinfo/python-dev
>Unsubscribe:
>https://mail.python.org/mailman/options/python-dev/paul%40ganssle.io
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.python.org/pipermail/python-dev/attachments/20190106/eeb269de/attachment.html>

From guido at python.org  Sun Jan  6 13:30:42 2019
From: guido at python.org (Guido van Rossum)
Date: Sun, 6 Jan 2019 11:30:42 -0700
Subject: [Python-Dev] Compilation of "except FooExc as var" adds useless
 store
In-Reply-To: <2457F573-1F15-4312-BBFF-0CB96452FC88@ganssle.io>
References: <20190106131048.6e0a3dd8@x230> <q0t6id$a79$1@blaine.gmane.org>
 <CAPTjJmoUbOH_8CRaUeUQ2mKBQPH_29WRZBrxidaOkYfT6Jt+2Q@mail.gmail.com>
 <q0t80n$m9u$1@blaine.gmane.org>
 <CAPTjJmr7EvUemFakEMto8fCO_5AbaW-ebqNbqQq3U=BJ3Xkqdg@mail.gmail.com>
 <5B21C86E-F904-44E8-BC8D-9E17BB31A9F0@ganssle.io>
 <CAPTjJmpsz_+0teVETV6YzZzMZ18rjtA1tVStCGoYxPzZs1jhCg@mail.gmail.com>
 <2457F573-1F15-4312-BBFF-0CB96452FC88@ganssle.io>
Message-ID: <CAP7+vJJE6Wx_Fd2_CeTfUtJuUyEaH_42_twHiKL47hRwviHr7Q@mail.gmail.com>

On Sun, Jan 6, 2019 at 9:40 AM Paul G <paul at ganssle.io> wrote:

> I am not familiar enough with the compiler logic, but would it be possible
> to optimize this away by detecting whether the bound name has already been
> deleted during the body of the except statement?
>

As was said before, it's not useful to optimize code that only runs on an
exception. (Though if there was a

On January 6, 2019 4:18:00 PM UTC, Chris Angelico <rosuav at gmail.com> wrote:
>
> On Mon, Jan 7, 2019 at 3:13 AM Paul G <paul at ganssle.io> wrote:
>
>>
>>  I think Serhiy is saying that if you delete exc before the except body ends, when the compiled code goes to delete it it will fail. Binding to None guarantees that there is something to delete.
>>
>
> Ahh! Thank you. I interpreted that example as a "this is what it
> compiles to", rather than actual source code that might fail. Can we
> get this example, suitably annotated, into the documentation
> somewhere?
>
>
I don't see a reason to document this behavior -- it would be strange if it
*didn't* work.

If we had an opcode to delete a variable but didn't raise if it is unset,
we could use that, but otherwise I see no action needed here.

-- 
--Guido van Rossum (python.org/~guido)
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.python.org/pipermail/python-dev/attachments/20190106/cd808d6b/attachment.html>

From andrew.svetlov at gmail.com  Sun Jan  6 13:29:55 2019
From: andrew.svetlov at gmail.com (Andrew Svetlov)
Date: Sun, 6 Jan 2019 20:29:55 +0200
Subject: [Python-Dev] Return type of datetime subclasses added to
 timedelta
In-Reply-To: <bb5120e0-159e-106d-04c6-2a15f7398966@ganssle.io>
References: <1059740e-cc65-205d-5986-a9397463a315@ganssle.io>
 <CAP7h-xa-Dp8TXrm7Oa=jDwf0wyBfVy-6zK08w219q0jVaYACiQ@mail.gmail.com>
 <bb5120e0-159e-106d-04c6-2a15f7398966@ganssle.io>
Message-ID: <CAL3CFcXCr-tJC==+a4VUav1-A6vsDZu5RMFB=Kyfm0x2yqm+Gg@mail.gmail.com>

>From my perspective datetime classes are even more complex than int/float.
Let's assume we have

class DT(datetime.datetime): ...
class TD(datetime.timedelta): ...

What is the result type for the following expressions?
DT - datetime
DT - DT
DT + TD
DT + timedelta

I have a feeling that the question has no generic answer.
For *particular* implementation you can override all __add__, __sub__
and other arithmetic operations, and you can do it right now with the
current datetime module implementation.

P.S.
I think inheritance from datetime classes is a very rare thing, 99.99% of
users don't need it.


On Sun, Jan 6, 2019 at 6:03 PM Paul Ganssle <paul at ganssle.io> wrote:

> I can think of many reasons why datetime is different from builtins,
> though to be honest I'm not sure that consistency for its own sake is
> really a strong argument for keeping a counter-intuitive behavior - and to
> be honest I'm open to the idea that *all* arithmetic types *should* have
> some form of this change.
>
> That said, I would say that the biggest difference between datetime and
> builtins (other than the fact that datetime is *not* a builtin, and as
> such doesn't necessarily need to be categorized in this group), is that
> unlike almost all other arithmetic types, *datetime* has a special,
> dedicated type for describing differences in datetimes. Using your example
> of a float subclass, consider that without the behavior of "addition of
> floats returns floats", it would be hard to predict what would happen in
> this situation:
>
> >>> F(1.2) + 3.4
>
> Would that always return a float, even though F(1.2) + F(3.4) returns an
> F? Would that return an F because F is the left-hand operand? Would it
> return a float because float is the right-hand operand? Would you walk the
> MROs and find the lowest type in common between the operands and return
> that? It's not entirely clear which subtype predominates. With datetime,
> you have:
>
> datetime - datetime -> timedelta
> datetime ? timedelta -> datetime
> timedelta ? timedelta -> timedelta
>
> There's no operation between two datetime objects that would return a
> datetime object, so it's always clear: operations between datetime
> subclasses return timedelta, operations between a datetime object and a
> timedelta return the subclass of the datetime that it was added to or
> subtracted from.
>
> Of course, the real way to resolve whether datetime should be different
> from int/float/string/etc is to look at why this choice was actually made
> for those types in the first place, and decide whether datetime is like
> them *in this respect*. The heterogeneous operations problem may be a
> reasonable justification for leaving the other builtins alone but changing
> datetime, but if someone knows of other fundamental reasons why the
> decision to have arithmetic operations always create the base class was
> chosen, please let me know.
>
> Best,
> Paul
> On 1/5/19 3:55 AM, Alexander Belopolsky wrote:
>
>
>
> On Wed, Jan 2, 2019 at 10:18 PM Paul Ganssle <paul at ganssle.io> wrote:
>
>> .. the original objection was that this implementation assumes that the
>> datetime subclass has a constructor with the same (or a sufficiently
>> similar) signature as datetime.
>>
> While this was used as a possible rationale for the way standard types
> behave, the main objection to changing datetime classes is that it will
> make them behave differently from builtins.  For example:
>
> >>> class F(float):
> ...     pass
> ...
> >>> type(F.fromhex('AA'))
> <class '__main__.F'>
> >>> type(F(1) + F(2))
> <class 'float'>
>
> This may be a legitimate gripe, but unfortunately that ship has sailed
>> long ago. All of datetime's alternate constructors make this assumption.
>> Any subclass that does not meet this requirement must have worked around it
>> long ago (or they don't care about alternate constructors).
>>
>
> This is right, but the same argument is equally applicable to int, float,
> etc. subclasses.  If you want to limit your change to datetime types you
> should explain what makes these types special.
>
> _______________________________________________
> Python-Dev mailing list
> Python-Dev at python.org
> https://mail.python.org/mailman/listinfo/python-dev
> Unsubscribe:
> https://mail.python.org/mailman/options/python-dev/andrew.svetlov%40gmail.com
>


-- 
Thanks,
Andrew Svetlov
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.python.org/pipermail/python-dev/attachments/20190106/63d736ae/attachment.html>

From guido at python.org  Sun Jan  6 13:43:18 2019
From: guido at python.org (Guido van Rossum)
Date: Sun, 6 Jan 2019 11:43:18 -0700
Subject: [Python-Dev] Return type of datetime subclasses added to
 timedelta
In-Reply-To: <bb5120e0-159e-106d-04c6-2a15f7398966@ganssle.io>
References: <1059740e-cc65-205d-5986-a9397463a315@ganssle.io>
 <CAP7h-xa-Dp8TXrm7Oa=jDwf0wyBfVy-6zK08w219q0jVaYACiQ@mail.gmail.com>
 <bb5120e0-159e-106d-04c6-2a15f7398966@ganssle.io>
Message-ID: <CAP7+vJL3JrRFstg_QNdq5C4kHkxdsbKyACJBxWSPUbyuTjao3g@mail.gmail.com>

I don't think datetime and builtins like int necessarily need to be
aligned. But I do see a problem -- the __new__ and __init__ methods defined
in the subclass (if any) should allow for being called with the same
signature as the base datetime class. Currently you can have a subclass of
datetime whose __new__ has no arguments (or, more realistically, interprets
its arguments differently). Instances of such a class can still be added to
a timedelta. The proposal would cause this to break (since such an addition
has to create a new instance, which calls __new__ and __init__). Since this
is a backwards incompatibility, I don't see how it can be done -- and I
also don't see many use cases, so I think it's not worth pursuing further.

Note that the same problem already happens with the .fromordinal() class
method, though it doesn't happen with .fromdatetime() or .now():

>>> class D(datetime.datetime):
...   def __new__(cls): return cls.now()
...
>>> D()
D(2019, 1, 6, 10, 33, 37, 161606)
>>> D.fromordinal(100)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: __new__() takes 1 positional argument but 4 were given
>>> D.fromtimestamp(123456789)
D(1973, 11, 29, 13, 33, 9)
>>>

On Sun, Jan 6, 2019 at 9:05 AM Paul Ganssle <paul at ganssle.io> wrote:

> I can think of many reasons why datetime is different from builtins,
> though to be honest I'm not sure that consistency for its own sake is
> really a strong argument for keeping a counter-intuitive behavior - and to
> be honest I'm open to the idea that *all* arithmetic types *should* have
> some form of this change.
>
> That said, I would say that the biggest difference between datetime and
> builtins (other than the fact that datetime is *not* a builtin, and as
> such doesn't necessarily need to be categorized in this group), is that
> unlike almost all other arithmetic types, *datetime* has a special,
> dedicated type for describing differences in datetimes. Using your example
> of a float subclass, consider that without the behavior of "addition of
> floats returns floats", it would be hard to predict what would happen in
> this situation:
>
> >>> F(1.2) + 3.4
>
> Would that always return a float, even though F(1.2) + F(3.4) returns an
> F? Would that return an F because F is the left-hand operand? Would it
> return a float because float is the right-hand operand? Would you walk the
> MROs and find the lowest type in common between the operands and return
> that? It's not entirely clear which subtype predominates. With datetime,
> you have:
>
> datetime - datetime -> timedelta
> datetime ? timedelta -> datetime
> timedelta ? timedelta -> timedelta
>
> There's no operation between two datetime objects that would return a
> datetime object, so it's always clear: operations between datetime
> subclasses return timedelta, operations between a datetime object and a
> timedelta return the subclass of the datetime that it was added to or
> subtracted from.
>
> Of course, the real way to resolve whether datetime should be different
> from int/float/string/etc is to look at why this choice was actually made
> for those types in the first place, and decide whether datetime is like
> them *in this respect*. The heterogeneous operations problem may be a
> reasonable justification for leaving the other builtins alone but changing
> datetime, but if someone knows of other fundamental reasons why the
> decision to have arithmetic operations always create the base class was
> chosen, please let me know.
>
> Best,
> Paul
> On 1/5/19 3:55 AM, Alexander Belopolsky wrote:
>
>
>
> On Wed, Jan 2, 2019 at 10:18 PM Paul Ganssle <paul at ganssle.io> wrote:
>
>> .. the original objection was that this implementation assumes that the
>> datetime subclass has a constructor with the same (or a sufficiently
>> similar) signature as datetime.
>>
> While this was used as a possible rationale for the way standard types
> behave, the main objection to changing datetime classes is that it will
> make them behave differently from builtins.  For example:
>
> >>> class F(float):
> ...     pass
> ...
> >>> type(F.fromhex('AA'))
> <class '__main__.F'>
> >>> type(F(1) + F(2))
> <class 'float'>
>
> This may be a legitimate gripe, but unfortunately that ship has sailed
>> long ago. All of datetime's alternate constructors make this assumption.
>> Any subclass that does not meet this requirement must have worked around it
>> long ago (or they don't care about alternate constructors).
>>
>
> This is right, but the same argument is equally applicable to int, float,
> etc. subclasses.  If you want to limit your change to datetime types you
> should explain what makes these types special.
>
> _______________________________________________
> Python-Dev mailing list
> Python-Dev at python.org
> https://mail.python.org/mailman/listinfo/python-dev
> Unsubscribe:
> https://mail.python.org/mailman/options/python-dev/guido%40python.org
>


-- 
--Guido van Rossum (python.org/~guido)
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.python.org/pipermail/python-dev/attachments/20190106/62f9bcb1/attachment.html>

From paul at ganssle.io  Sun Jan  6 13:42:58 2019
From: paul at ganssle.io (Paul Ganssle)
Date: Sun, 6 Jan 2019 13:42:58 -0500
Subject: [Python-Dev] Return type of datetime subclasses added to
 timedelta
In-Reply-To: <CAL3CFcXCr-tJC==+a4VUav1-A6vsDZu5RMFB=Kyfm0x2yqm+Gg@mail.gmail.com>
References: <1059740e-cc65-205d-5986-a9397463a315@ganssle.io>
 <CAP7h-xa-Dp8TXrm7Oa=jDwf0wyBfVy-6zK08w219q0jVaYACiQ@mail.gmail.com>
 <bb5120e0-159e-106d-04c6-2a15f7398966@ganssle.io>
 <CAL3CFcXCr-tJC==+a4VUav1-A6vsDZu5RMFB=Kyfm0x2yqm+Gg@mail.gmail.com>
Message-ID: <e7dab004-f861-93f7-970a-5ec5e97be6fc@ganssle.io>


On 1/6/19 1:29 PM, Andrew Svetlov wrote:
> From my perspective datetime?classes are even more complex than int/float.
> Let's assume we have
>
> class DT(datetime.datetime): ...
> class TD(datetime.timedelta): ...
>
> What is the result type for the following expressions?
> DT - datetime
> DT - DT
> DT?+ TD
> DT?+ timedelta
>
It is not really complicated, the default "difference between two
datetimes" returns a `timedelta`, you can change that by overriding
`__sub__` or `__rsub__` as desired, but there's no reason to think that
the fact that just because DT is a subclass of datetime that it would be
coupled to a specific timedelta subclass *by default*.

Similarly, DT + TD by default will do whatever "datetime" and
"timedelta" do unless you specifically override them. In my proposal,
adding some time to a datetime subclass would return an object of the
datetime subclass, so unless __radd__ or __rsub__ were overriden in
`timedelta`, that's what would happen, the defaults would be (sensibly):

DT - datetime -> timedelta
DT - DT -> timedelta
DT + TD -> DT
DT + timedelta -> timedelta

The only time it would be more complicated is if datetime were defined
like this:

class datetime:
??? TIMEDELTA_CLASS = datetime.timedelta
??? ...

In which case you'd have the same problem you have with float/int/etc
(not a particularly more complicated one. But that's not the case, and
there /is/ one obviously right answer. This is not the case with float
subclasses, because the intuitive rule is "adding together two objects
of the same class gives the same class", which fails when you have two
different subclasses. With datetime, you have "adding a delta type to a
value type returns an object of the value type", which makes perfect
sense, as opposed to "adding a delta type to a value type returns the
base value type, even if the base value type was never used".


> I have a feeling that the question has no generic answer.
> For *particular* implementation you can override all __add__, __sub__
> and other arithmetic operations, and you can do it right now with the
> current datetime?module implementation.
> P.S.
> I think inheritance from datetime?classes is a very rare thing, 99.99%
> of users don't need it.
>
Both of these points are addressed in my original post, IIRC, but both
of these arguments cut both ways. Assuming it's true that this is very
rare - the 0.01% of people who /are/ subclassing datetime either don't
care about this behavior or want timedelta arithmetic to return their
subclass. It's rare enough that there should be no problem giving them
what they want.

Similarly, the rarest group - people who are creating datetime
subclasses /and/ want the original behavior - can simply implement
__add__ and __sub__ to get what they want, so there's no real conflict,
it's just a matter of setting a sane default that also solves the
problem that datetime alternate constructors tend to leak their
implementation details because of the arithmetic return type issue.


Best, Paul

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.python.org/pipermail/python-dev/attachments/20190106/e7ce698c/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: OpenPGP digital signature
URL: <http://mail.python.org/pipermail/python-dev/attachments/20190106/e7ce698c/attachment-0001.sig>

From storchaka at gmail.com  Sun Jan  6 13:44:23 2019
From: storchaka at gmail.com (Serhiy Storchaka)
Date: Sun, 6 Jan 2019 20:44:23 +0200
Subject: [Python-Dev] Compilation of "except FooExc as var" adds useless
 store
In-Reply-To: <CAPTjJmr7EvUemFakEMto8fCO_5AbaW-ebqNbqQq3U=BJ3Xkqdg@mail.gmail.com>
References: <20190106131048.6e0a3dd8@x230> <q0t6id$a79$1@blaine.gmane.org>
 <CAPTjJmoUbOH_8CRaUeUQ2mKBQPH_29WRZBrxidaOkYfT6Jt+2Q@mail.gmail.com>
 <q0t80n$m9u$1@blaine.gmane.org>
 <CAPTjJmr7EvUemFakEMto8fCO_5AbaW-ebqNbqQq3U=BJ3Xkqdg@mail.gmail.com>
Message-ID: <q0ti64$cci$1@blaine.gmane.org>

06.01.19 18:05, Chris Angelico ????:
> Which I read, and they do not explain the assignment of None. The only
> reference is that the tracker issue mentions having a test case to
> ensure that it's happening, which is further proof that it's
> intentional, but still fails to explain *why*.

This is explained on a discussion on the Python-3000 mailing list. I 
provided a code example which would fail if do not perform such 
assignment. The test, mentioned in the tracker issue, contains similar code.


From pmiscml at gmail.com  Sun Jan  6 13:48:39 2019
From: pmiscml at gmail.com (Paul Sokolovsky)
Date: Sun, 6 Jan 2019 20:48:39 +0200
Subject: [Python-Dev] Compilation of "except FooExc as var" adds useless
 store
In-Reply-To: <q0t6id$a79$1@blaine.gmane.org>
References: <20190106131048.6e0a3dd8@x230>
	<q0t6id$a79$1@blaine.gmane.org>
Message-ID: <20190106204839.2dccb050@x230>

Hello,

On Sun, 6 Jan 2019 17:26:09 +0200
Serhiy Storchaka <storchaka at gmail.com> wrote:

[]

> Because there is a reason for such code.
> 
> See issue1631942 [1] and the thread with the subject "self-contained 
> exceptions" on the Python-3000 mailing list [2] for the rationale.
> 
> In short, the code
> 
>      try:
>          1/0
>      except Exception as e:
>          del e
> 
> should work.

(Dark) Magic. Live and learn/think. So, we allow user to delete a var,
then recreate it, just to delete again. Thanks for both the hint and
references, Serhiy!

I can only agree with what Chris wrote in the initial reply - it
would nice if there would be an explanation of these tricks somewhere.
I myself wouldn't know a better place than the source code comments.
Well, at least I did trace it to the source code where it's handled.

> I do not see a problem with storing None before deleting a variable. 
> This is not a performance critical code, because it is executed only 
> when an exception was raised and caught.

From CPython's points of view, I might (well, have to) agree. But I was
pretty surprised/disappointed that MicroPython follows the same
routine, I'm glad I now understand ins and outs of the choices made.

> 
> [1] https://bugs.python.org/issue1631942
> [2]
> https://mail.python.org/pipermail/python-3000/2007-January/005294.html


-- 
Best regards,
 Paul                          mailto:pmiscml at gmail.com

From paul at ganssle.io  Sun Jan  6 13:59:06 2019
From: paul at ganssle.io (Paul Ganssle)
Date: Sun, 6 Jan 2019 13:59:06 -0500
Subject: [Python-Dev] Return type of datetime subclasses added to
 timedelta
In-Reply-To: <CAP7+vJL3JrRFstg_QNdq5C4kHkxdsbKyACJBxWSPUbyuTjao3g@mail.gmail.com>
References: <1059740e-cc65-205d-5986-a9397463a315@ganssle.io>
 <CAP7h-xa-Dp8TXrm7Oa=jDwf0wyBfVy-6zK08w219q0jVaYACiQ@mail.gmail.com>
 <bb5120e0-159e-106d-04c6-2a15f7398966@ganssle.io>
 <CAP7+vJL3JrRFstg_QNdq5C4kHkxdsbKyACJBxWSPUbyuTjao3g@mail.gmail.com>
Message-ID: <2415dd60-b6b4-30b0-90d2-c0c8b22314c7@ganssle.io>

I did address this in the original post - the assumption that the
subclass constructor will have the same arguments as the base
constructor is baked into many alternate constructors of datetime. I
acknowledge that this is a breaking change, but it is a small one -
anyone creating such a subclass that /cannot/ handled the class being
created this way would be broken in myriad ways.

We have also in recent years changed several alternate constructors
(including `replace`) to retain the original subclass, which by your
same standard would be a breaking change. I believe there have been no
complaints. In fact, between Python 3.6 and 3.7, the very example you
showed broke:

Python 3.6.6:

>>> class D(datetime.datetime):
...???? def __new__(cls):
...???????? return cls.now()
...
>>> D()
D(2019, 1, 6, 13, 49, 38, 842033)

Python 3.7.2:

>>> class D(datetime.datetime):
...???? def __new__(cls):
...???????? return cls.now()
...
>>> D()
Traceback (most recent call last):
? File "<stdin>", line 1, in <module>
? File "<stdin>", line 3, in __new__
TypeError: __new__() takes 1 positional argument but 9 were given


We haven't seen any bug reports about this sort of thing; what we /have/
been getting is bug reports that subclassing datetime doesn't retain the
subclass in various ways (because people /are/ using datetime
subclasses). This is likely to cause very little in the way of problems,
but it will improve convenience for people making datetime subclasses
and almost certainly performance for people using them (e.g. pendulum
and arrow, which now need to take a slow pure python route in many
situations to work around this problem).

If we're /really/ concerned with this backward compatibility breaking,
we could do the equivalent of:

try:
??? return new_behavior(...)
except TypeError:
??? warnings.warn("The semantics of timedelta addition have "
????????????????? "changed in a way that raises an error in "
????????????????? "this subclass. Please implement __add__ "
????????????????? "if you need the old behavior.", DeprecationWarning)

Then after a suitable notice period drop the warning and turn it to a
hard error.

Best,

Paul

On 1/6/19 1:43 PM, Guido van Rossum wrote:
> I don't think datetime and builtins like int necessarily need to be
> aligned. But I do see a problem -- the __new__ and __init__ methods
> defined in the subclass (if any) should allow for being called with
> the same signature as the base datetime class. Currently you can have
> a subclass of datetime whose __new__ has no arguments (or, more
> realistically, interprets its arguments differently). Instances of
> such a class can still be added to a timedelta. The proposal would
> cause this to break (since such an addition has to create a new
> instance, which calls __new__ and __init__). Since this is a backwards
> incompatibility, I don't see how it can be done -- and I also don't
> see many use cases, so I think it's not worth pursuing further.
>
> Note that the same problem already happens with the .fromordinal()
> class method, though it doesn't happen with .fromdatetime() or .now():
>
> >>> class D(datetime.datetime):
> ...?? def __new__(cls): return cls.now()
> ...
> >>> D()
> D(2019, 1, 6, 10, 33, 37, 161606)
> >>> D.fromordinal(100)
> Traceback (most recent call last):
> ? File "<stdin>", line 1, in <module>
> TypeError: __new__() takes 1 positional argument but 4 were given
> >>> D.fromtimestamp(123456789)
> D(1973, 11, 29, 13, 33, 9)
> >>>
>
> On Sun, Jan 6, 2019 at 9:05 AM Paul Ganssle <paul at ganssle.io
> <mailto:paul at ganssle.io>> wrote:
>
>     I can think of many reasons why datetime is different from
>     builtins, though to be honest I'm not sure that consistency for
>     its own sake is really a strong argument for keeping a
>     counter-intuitive behavior - and to be honest I'm open to the idea
>     that /all/ arithmetic types /should/ have some form of this change.
>
>     That said, I would say that the biggest difference between
>     datetime and builtins (other than the fact that datetime is /not/
>     a builtin, and as such doesn't necessarily need to be categorized
>     in this group), is that unlike almost all other arithmetic types,
>     /datetime/ has a special, dedicated type for describing
>     differences in datetimes. Using your example of a float subclass,
>     consider that without the behavior of "addition of floats returns
>     floats", it would be hard to predict what would happen in this
>     situation:
>
>     >>> F(1.2) + 3.4
>
>     Would that always return a float, even though F(1.2) + F(3.4)
>     returns an F? Would that return an F because F is the left-hand
>     operand? Would it return a float because float is the right-hand
>     operand? Would you walk the MROs and find the lowest type in
>     common between the operands and return that? It's not entirely
>     clear which subtype predominates. With datetime, you have:
>
>     datetime - datetime -> timedelta
>     datetime ? timedelta -> datetime
>     timedelta ? timedelta -> timedelta
>
>     There's no operation between two datetime objects that would
>     return a datetime object, so it's always clear: operations between
>     datetime subclasses return timedelta, operations between a
>     datetime object and a timedelta return the subclass of the
>     datetime that it was added to or subtracted from.
>
>     Of course, the real way to resolve whether datetime should be
>     different from int/float/string/etc is to look at why this choice
>     was actually made for those types in the first place, and decide
>     whether datetime is like them /in this respect/. The heterogeneous
>     operations problem may be a reasonable justification for leaving
>     the other builtins alone but changing datetime, but if someone
>     knows of other fundamental reasons why the decision to have
>     arithmetic operations always create the base class was chosen,
>     please let me know.
>
>     Best,
>     Paul
>
>     On 1/5/19 3:55 AM, Alexander Belopolsky wrote:
>>
>>
>>     On Wed, Jan 2, 2019 at 10:18 PM Paul Ganssle <paul at ganssle.io
>>     <mailto:paul at ganssle.io>> wrote:
>>
>>         .. the original objection was that this implementation
>>         assumes that the datetime subclass has a constructor with the
>>         same (or a sufficiently similar) signature as datetime.
>>
>>     While this was used as a possible rationale for the way standard
>>     types behave, the main objection to changing datetime classes is
>>     that it will make them behave differently from builtins.? For
>>     example:
>>
>>     >>> class F(float):
>>     ...? ? ?pass
>>     ...
>>     >>> type(F.fromhex('AA'))
>>     <class '__main__.F'>
>>     >>> type(F(1) + F(2))
>>     <class 'float'>
>>
>>         This may be a legitimate gripe, but unfortunately that ship
>>         has sailed long ago. All of datetime's alternate constructors
>>         make this assumption. Any subclass that does not meet this
>>         requirement must have worked around it long ago (or they
>>         don't care about alternate constructors).
>>
>>
>>     This is right, but the same argument is equally applicable to
>>     int, float, etc. subclasses.? If you want to limit your change to
>>     datetime types you should explain what makes these types special.??
>     _______________________________________________
>     Python-Dev mailing list
>     Python-Dev at python.org <mailto:Python-Dev at python.org>
>     https://mail.python.org/mailman/listinfo/python-dev
>     Unsubscribe:
>     https://mail.python.org/mailman/options/python-dev/guido%40python.org
>
>
>
> -- 
> --Guido van Rossum (python.org/~guido <http://python.org/~guido>)
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.python.org/pipermail/python-dev/attachments/20190106/a8b25999/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: OpenPGP digital signature
URL: <http://mail.python.org/pipermail/python-dev/attachments/20190106/a8b25999/attachment.sig>

From pmiscml at gmail.com  Sun Jan  6 15:11:45 2019
From: pmiscml at gmail.com (Paul Sokolovsky)
Date: Sun, 6 Jan 2019 22:11:45 +0200
Subject: [Python-Dev] Compilation of "except FooExc as var" adds useless
 store
In-Reply-To: <20190106141453.GY13616@ando.pearwood.info>
References: <20190106131048.6e0a3dd8@x230>
 <20190106121011.GX13616@ando.pearwood.info>
 <20190106150303.57b77c5a@x230>
 <20190106141453.GY13616@ando.pearwood.info>
Message-ID: <20190106221145.43021319@x230>

Hello,

On Mon, 7 Jan 2019 01:14:55 +1100
Steven D'Aprano <steve at pearwood.info> wrote:

[]

> > Thanks, that summarizes it well. And well, my interest is also how
> > non-compliant would be for another Python implementation to act
> > differently, specifically to skip wrapping an except handler body in
> > try-finally (i.e., go back to Python2 behavior). I'm keen to add
> > such an option to my fork of MicroPython.  
> 
> Wouldn't that mean that MicroPython suffers from the
> exception/traceback reference cycle problem? How do you propose to
> solve that?

To answer this, MicroPython doesn't have reference counting and relies
solely on garbage collection, so breaking cycles early wouldn't have
much effect. Breaking stray links to should-be-dead data structures
might (to allow them to be collected sooner rather than later), but
probably not at the expense of introducing extra entry in the block
stack. (That may seems like breadcrumb saving, but saving a few
percents of overhead in many places is how MicroPython achieves
its promise of programming small embedded systems in a very high level
language.)

[]

-- 
Best regards,
 Paul                          mailto:pmiscml at gmail.com

From brett at python.org  Sun Jan  6 15:17:47 2019
From: brett at python.org (Brett Cannon)
Date: Sun, 6 Jan 2019 12:17:47 -0800
Subject: [Python-Dev] Compilation of "except FooExc as var" adds useless
 store
In-Reply-To: <CAP7+vJJE6Wx_Fd2_CeTfUtJuUyEaH_42_twHiKL47hRwviHr7Q@mail.gmail.com>
References: <20190106131048.6e0a3dd8@x230> <q0t6id$a79$1@blaine.gmane.org>
 <CAPTjJmoUbOH_8CRaUeUQ2mKBQPH_29WRZBrxidaOkYfT6Jt+2Q@mail.gmail.com>
 <q0t80n$m9u$1@blaine.gmane.org>
 <CAPTjJmr7EvUemFakEMto8fCO_5AbaW-ebqNbqQq3U=BJ3Xkqdg@mail.gmail.com>
 <5B21C86E-F904-44E8-BC8D-9E17BB31A9F0@ganssle.io>
 <CAPTjJmpsz_+0teVETV6YzZzMZ18rjtA1tVStCGoYxPzZs1jhCg@mail.gmail.com>
 <2457F573-1F15-4312-BBFF-0CB96452FC88@ganssle.io>
 <CAP7+vJJE6Wx_Fd2_CeTfUtJuUyEaH_42_twHiKL47hRwviHr7Q@mail.gmail.com>
Message-ID: <CAP1=2W4LvbgutAfsuB=XCxeD1R8Jf9LYsiC+ORaP81UAfRhocA@mail.gmail.com>

On Sun, 6 Jan 2019 at 10:26, Guido van Rossum <guido at python.org> wrote:

> On Sun, Jan 6, 2019 at 9:40 AM Paul G <paul at ganssle.io> wrote:
>
>> I am not familiar enough with the compiler logic, but would it be
>> possible to optimize this away by detecting whether the bound name has
>> already been deleted during the body of the except statement?
>>
>
> As was said before, it's not useful to optimize code that only runs on an
> exception. (Though if there was a
>
> On January 6, 2019 4:18:00 PM UTC, Chris Angelico <rosuav at gmail.com>
> wrote:
>>
>> On Mon, Jan 7, 2019 at 3:13 AM Paul G <paul at ganssle.io> wrote:
>>
>>>
>>>  I think Serhiy is saying that if you delete exc before the except body ends, when the compiled code goes to delete it it will fail. Binding to None guarantees that there is something to delete.
>>>
>>
>> Ahh! Thank you. I interpreted that example as a "this is what it
>> compiles to", rather than actual source code that might fail. Can we
>> get this example, suitably annotated, into the documentation
>> somewhere?
>>
>>
> I don't see a reason to document this behavior -- it would be strange if
> it *didn't* work.
>
> If we had an opcode to delete a variable but didn't raise if it is unset,
> we could use that, but otherwise I see no action needed here.
>

Maybe someone can propose a code comment to explain this instead? I agree
that this doesn't need to be explained in the language spec, but I don't
see any harm in a comment where the opcodes are emitted to explain why it
is the way it is .
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.python.org/pipermail/python-dev/attachments/20190106/df49faca/attachment.html>

From rosuav at gmail.com  Sun Jan  6 15:22:19 2019
From: rosuav at gmail.com (Chris Angelico)
Date: Mon, 7 Jan 2019 07:22:19 +1100
Subject: [Python-Dev] Compilation of "except FooExc as var" adds useless
 store
In-Reply-To: <CAP1=2W4LvbgutAfsuB=XCxeD1R8Jf9LYsiC+ORaP81UAfRhocA@mail.gmail.com>
References: <20190106131048.6e0a3dd8@x230> <q0t6id$a79$1@blaine.gmane.org>
 <CAPTjJmoUbOH_8CRaUeUQ2mKBQPH_29WRZBrxidaOkYfT6Jt+2Q@mail.gmail.com>
 <q0t80n$m9u$1@blaine.gmane.org>
 <CAPTjJmr7EvUemFakEMto8fCO_5AbaW-ebqNbqQq3U=BJ3Xkqdg@mail.gmail.com>
 <5B21C86E-F904-44E8-BC8D-9E17BB31A9F0@ganssle.io>
 <CAPTjJmpsz_+0teVETV6YzZzMZ18rjtA1tVStCGoYxPzZs1jhCg@mail.gmail.com>
 <2457F573-1F15-4312-BBFF-0CB96452FC88@ganssle.io>
 <CAP7+vJJE6Wx_Fd2_CeTfUtJuUyEaH_42_twHiKL47hRwviHr7Q@mail.gmail.com>
 <CAP1=2W4LvbgutAfsuB=XCxeD1R8Jf9LYsiC+ORaP81UAfRhocA@mail.gmail.com>
Message-ID: <CAPTjJmrPoeGXdM4dbE0YpnXb4m5UR98-vcTsKgOzor+eT9uihQ@mail.gmail.com>

On Mon, Jan 7, 2019 at 7:18 AM Brett Cannon <brett at python.org> wrote:
>
> Maybe someone can propose a code comment to explain this instead? I agree that this doesn't need to be explained in the language spec, but I don't see any harm in a comment where the opcodes are emitted to explain why it is the way it is .
>

No BPO as yet but here's a tracker issue to get started.

https://github.com/python/cpython/pull/11448

ChrisA

From brett at python.org  Sun Jan  6 15:24:54 2019
From: brett at python.org (Brett Cannon)
Date: Sun, 6 Jan 2019 12:24:54 -0800
Subject: [Python-Dev] Return type of datetime subclasses added to
 timedelta
In-Reply-To: <2415dd60-b6b4-30b0-90d2-c0c8b22314c7@ganssle.io>
References: <1059740e-cc65-205d-5986-a9397463a315@ganssle.io>
 <CAP7h-xa-Dp8TXrm7Oa=jDwf0wyBfVy-6zK08w219q0jVaYACiQ@mail.gmail.com>
 <bb5120e0-159e-106d-04c6-2a15f7398966@ganssle.io>
 <CAP7+vJL3JrRFstg_QNdq5C4kHkxdsbKyACJBxWSPUbyuTjao3g@mail.gmail.com>
 <2415dd60-b6b4-30b0-90d2-c0c8b22314c7@ganssle.io>
Message-ID: <CAP1=2W7RnpW7HgpuDQPzZzfrMMzPXAGj8G91xQyRMU4qLV1btg@mail.gmail.com>

On Sun, 6 Jan 2019 at 11:00, Paul Ganssle <paul at ganssle.io> wrote:

> I did address this in the original post - the assumption that the subclass
> constructor will have the same arguments as the base constructor is baked
> into many alternate constructors of datetime. I acknowledge that this is a
> breaking change, but it is a small one - anyone creating such a subclass
> that *cannot* handled the class being created this way would be broken in
> myriad ways.
>
> We have also in recent years changed several alternate constructors
> (including `replace`) to retain the original subclass, which by your same
> standard would be a breaking change. I believe there have been no
> complaints. In fact, between Python 3.6 and 3.7, the very example you
> showed broke:
>
> Python 3.6.6:
>
> >>> class D(datetime.datetime):
> ...     def __new__(cls):
> ...         return cls.now()
> ...
> >>> D()
> D(2019, 1, 6, 13, 49, 38, 842033)
>
> Python 3.7.2:
>
> >>> class D(datetime.datetime):
> ...     def __new__(cls):
> ...         return cls.now()
> ...
> >>> D()
> Traceback (most recent call last):
>   File "<stdin>", line 1, in <module>
>   File "<stdin>", line 3, in __new__
> TypeError: __new__() takes 1 positional argument but 9 were given
>
>
> We haven't seen any bug reports about this sort of thing; what we *have*
> been getting is bug reports that subclassing datetime doesn't retain the
> subclass in various ways (because people *are* using datetime subclasses).
>

To help set expectations, the current semantics are not a bug and so the
proposal isn't fixing a bug but proposing a change in semantics.


> This is likely to cause very little in the way of problems, but it will
> improve convenience for people making datetime subclasses and almost
> certainly performance for people using them (e.g. pendulum and arrow, which
> now need to take a slow pure python route in many situations to work around
> this problem).
>
> If we're *really* concerned with this backward compatibility breaking,
>

We very much do care. Because this isn't a bug but a voluntary semantic
change you're proposing to change we can't blindly break people who are
relying on the current semantics. We need to have a justification for those
people as to why we have decided to change the semantics now after all of
these years as well as provide an upgrade path.

-Brett


> we could do the equivalent of:
>
> try:
>     return new_behavior(...)
> except TypeError:
>     warnings.warn("The semantics of timedelta addition have "
>                   "changed in a way that raises an error in "
>                   "this subclass. Please implement __add__ "
>                   "if you need the old behavior.", DeprecationWarning)
>

> Then after a suitable notice period drop the warning and turn it to a hard
> error.
>
> Best,
>
> Paul
> On 1/6/19 1:43 PM, Guido van Rossum wrote:
>
> I don't think datetime and builtins like int necessarily need to be
> aligned. But I do see a problem -- the __new__ and __init__ methods defined
> in the subclass (if any) should allow for being called with the same
> signature as the base datetime class. Currently you can have a subclass of
> datetime whose __new__ has no arguments (or, more realistically, interprets
> its arguments differently). Instances of such a class can still be added to
> a timedelta. The proposal would cause this to break (since such an addition
> has to create a new instance, which calls __new__ and __init__). Since this
> is a backwards incompatibility, I don't see how it can be done -- and I
> also don't see many use cases, so I think it's not worth pursuing further.
>
> Note that the same problem already happens with the .fromordinal() class
> method, though it doesn't happen with .fromdatetime() or .now():
>
> >>> class D(datetime.datetime):
> ...   def __new__(cls): return cls.now()
> ...
> >>> D()
> D(2019, 1, 6, 10, 33, 37, 161606)
> >>> D.fromordinal(100)
> Traceback (most recent call last):
>   File "<stdin>", line 1, in <module>
> TypeError: __new__() takes 1 positional argument but 4 were given
> >>> D.fromtimestamp(123456789)
> D(1973, 11, 29, 13, 33, 9)
> >>>
>
> On Sun, Jan 6, 2019 at 9:05 AM Paul Ganssle <paul at ganssle.io> wrote:
>
>> I can think of many reasons why datetime is different from builtins,
>> though to be honest I'm not sure that consistency for its own sake is
>> really a strong argument for keeping a counter-intuitive behavior - and to
>> be honest I'm open to the idea that *all* arithmetic types *should* have
>> some form of this change.
>>
>> That said, I would say that the biggest difference between datetime and
>> builtins (other than the fact that datetime is *not* a builtin, and as
>> such doesn't necessarily need to be categorized in this group), is that
>> unlike almost all other arithmetic types, *datetime* has a special,
>> dedicated type for describing differences in datetimes. Using your example
>> of a float subclass, consider that without the behavior of "addition of
>> floats returns floats", it would be hard to predict what would happen in
>> this situation:
>>
>> >>> F(1.2) + 3.4
>>
>> Would that always return a float, even though F(1.2) + F(3.4) returns an
>> F? Would that return an F because F is the left-hand operand? Would it
>> return a float because float is the right-hand operand? Would you walk the
>> MROs and find the lowest type in common between the operands and return
>> that? It's not entirely clear which subtype predominates. With datetime,
>> you have:
>>
>> datetime - datetime -> timedelta
>> datetime ? timedelta -> datetime
>> timedelta ? timedelta -> timedelta
>>
>> There's no operation between two datetime objects that would return a
>> datetime object, so it's always clear: operations between datetime
>> subclasses return timedelta, operations between a datetime object and a
>> timedelta return the subclass of the datetime that it was added to or
>> subtracted from.
>>
>> Of course, the real way to resolve whether datetime should be different
>> from int/float/string/etc is to look at why this choice was actually made
>> for those types in the first place, and decide whether datetime is like
>> them *in this respect*. The heterogeneous operations problem may be a
>> reasonable justification for leaving the other builtins alone but changing
>> datetime, but if someone knows of other fundamental reasons why the
>> decision to have arithmetic operations always create the base class was
>> chosen, please let me know.
>>
>> Best,
>> Paul
>> On 1/5/19 3:55 AM, Alexander Belopolsky wrote:
>>
>>
>>
>> On Wed, Jan 2, 2019 at 10:18 PM Paul Ganssle <paul at ganssle.io> wrote:
>>
>>> .. the original objection was that this implementation assumes that the
>>> datetime subclass has a constructor with the same (or a sufficiently
>>> similar) signature as datetime.
>>>
>> While this was used as a possible rationale for the way standard types
>> behave, the main objection to changing datetime classes is that it will
>> make them behave differently from builtins.  For example:
>>
>> >>> class F(float):
>> ...     pass
>> ...
>> >>> type(F.fromhex('AA'))
>> <class '__main__.F'>
>> >>> type(F(1) + F(2))
>> <class 'float'>
>>
>> This may be a legitimate gripe, but unfortunately that ship has sailed
>>> long ago. All of datetime's alternate constructors make this assumption.
>>> Any subclass that does not meet this requirement must have worked around it
>>> long ago (or they don't care about alternate constructors).
>>>
>>
>> This is right, but the same argument is equally applicable to int, float,
>> etc. subclasses.  If you want to limit your change to datetime types you
>> should explain what makes these types special.
>>
>> _______________________________________________
>> Python-Dev mailing list
>> Python-Dev at python.org
>> https://mail.python.org/mailman/listinfo/python-dev
>> Unsubscribe:
>> https://mail.python.org/mailman/options/python-dev/guido%40python.org
>>
>
>
> --
> --Guido van Rossum (python.org/~guido)
>
> _______________________________________________
> Python-Dev mailing list
> Python-Dev at python.org
> https://mail.python.org/mailman/listinfo/python-dev
> Unsubscribe:
> https://mail.python.org/mailman/options/python-dev/brett%40python.org
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.python.org/pipermail/python-dev/attachments/20190106/d2e2d630/attachment.html>

From paul at ganssle.io  Sun Jan  6 15:50:32 2019
From: paul at ganssle.io (Paul Ganssle)
Date: Sun, 6 Jan 2019 15:50:32 -0500
Subject: [Python-Dev] Return type of datetime subclasses added to
 timedelta
In-Reply-To: <CAP1=2W7RnpW7HgpuDQPzZzfrMMzPXAGj8G91xQyRMU4qLV1btg@mail.gmail.com>
References: <1059740e-cc65-205d-5986-a9397463a315@ganssle.io>
 <CAP7h-xa-Dp8TXrm7Oa=jDwf0wyBfVy-6zK08w219q0jVaYACiQ@mail.gmail.com>
 <bb5120e0-159e-106d-04c6-2a15f7398966@ganssle.io>
 <CAP7+vJL3JrRFstg_QNdq5C4kHkxdsbKyACJBxWSPUbyuTjao3g@mail.gmail.com>
 <2415dd60-b6b4-30b0-90d2-c0c8b22314c7@ganssle.io>
 <CAP1=2W7RnpW7HgpuDQPzZzfrMMzPXAGj8G91xQyRMU4qLV1btg@mail.gmail.com>
Message-ID: <ba6bdb89-9a60-e46f-8037-7b013a478db3@ganssle.io>

Brett,

Thank you for bringing this up, but I think you /may/ have misunderstood
my position - though maybe you understood the thrust and wanted to
clarify for people coming in halfway, which I applaud.

I proposed this change /knowing/ that it was a breaking change - it's
why I brought it to the attention of datetime-SIG and now python-dev -
and I believe that there are several factors that lead this to being a
smaller compatibility problem than it seems.

One such factor is the fact that /many/ other features of `datetime`,
including the implementation of `datetime.now()` are /already broken/ in
the current implementation for anyone who would be broken by this
particular aspect of the semantic change. That is not saying that it's
impossible that there is code out there that will break if this change
goes through, it's just saying that the scope of the breakage is
necessarily very limited.

The reason I brought up the bug tracker is because between Python 3.6
and Python 3.7, we in fact made a similar breaking change to the one I'm
proposing here without thinking that anyone might be relying on the fact
that they could do something like:

class D(datetime.datetime):
??? def __new__(cls):
??????? return cls.now()

My point was that there have been no bug reports about the /existing
change/ that Guido was bringing up (his example itself does not work on
Python 3.7!), which leads me to believe that few if any people are
relying on the fact that it is possible to define a datetime subclass
with a different default constructor.

As I mentioned, it is likely possible to have a transition period where
this would still work even if the subclassers have not created their own
__add__ method.

There is no way to create a similar deprecation/transition period for
people relying on the fact that `type(datetime_obj + timedelta_obj) ==
datetime.datetime`, but I think this is honestly a sufficiently minor
breakage that the good outweighs the harm. I will note that we have
already made several such changes with respect to alternate constructors
even though technically someone could have been relying on the fact that
`MyDateTime(*args).replace(month=3)` returns a `datetime` object.

This is not to say that we should lightly make the change (hence my
canvassing for opinions), it is just that there is a good amount of
evidence that, practically speaking, no one is relying on this, and in
fact it is likely that people are writing code that assumes that adding
`timedelta` to a datetime subclass returns the original subclass, either
directly or indirectly - I think we're likely to fix more people than we
break if we make this change.

Best,
Paul


On 1/6/19 3:24 PM, Brett Cannon wrote:
>
>
> On Sun, 6 Jan 2019 at 11:00, Paul Ganssle <paul at ganssle.io
> <mailto:paul at ganssle.io>> wrote:
>
>     I did address this in the original post - the assumption that the
>     subclass constructor will have the same arguments as the base
>     constructor is baked into many alternate constructors of datetime.
>     I acknowledge that this is a breaking change, but it is a small
>     one - anyone creating such a subclass that /cannot/ handled the
>     class being created this way would be broken in myriad ways.
>
>     We have also in recent years changed several alternate
>     constructors (including `replace`) to retain the original
>     subclass, which by your same standard would be a breaking change.
>     I believe there have been no complaints. In fact, between Python
>     3.6 and 3.7, the very example you showed broke:
>
>     Python 3.6.6:
>
>     >>> class D(datetime.datetime):
>     ...???? def __new__(cls):
>     ...???????? return cls.now()
>     ...
>     >>> D()
>     D(2019, 1, 6, 13, 49, 38, 842033)
>
>     Python 3.7.2:
>
>     >>> class D(datetime.datetime):
>     ...???? def __new__(cls):
>     ...???????? return cls.now()
>     ...
>     >>> D()
>     Traceback (most recent call last):
>     ? File "<stdin>", line 1, in <module>
>     ? File "<stdin>", line 3, in __new__
>     TypeError: __new__() takes 1 positional argument but 9 were given
>
>
>     We haven't seen any bug reports about this sort of thing; what we
>     /have/ been getting is bug reports that subclassing datetime
>     doesn't retain the subclass in various ways (because people /are/
>     using datetime subclasses).
>
>
> To help set expectations, the current semantics are not a bug and so
> the proposal isn't fixing a bug but proposing a change in semantics.
> ?
>
>     This is likely to cause very little in the way of problems, but it
>     will improve convenience for people making datetime subclasses and
>     almost certainly performance for people using them (e.g. pendulum
>     and arrow, which now need to take a slow pure python route in many
>     situations to work around this problem).
>
>     If we're /really/ concerned with this backward compatibility
>     breaking,
>
>
> We very much do care. Because this isn't a bug but a voluntary
> semantic change you're proposing to change we can't blindly break
> people who are relying on the current semantics. We need to have a
> justification for those people as to why we have decided to change the
> semantics now after all of these years as well as provide an upgrade path.
>
> -Brett
> ?
>
>     we could do the equivalent of:
>
>     try:
>     ??? return new_behavior(...)
>     except TypeError:
>     ??? warnings.warn("The semantics of timedelta addition have "
>     ????????????????? "changed in a way that raises an error in "
>     ????????????????? "this subclass. Please implement __add__ "
>     ????????????????? "if you need the old behavior.",
>     DeprecationWarning)?
>
>
>     Then after a suitable notice period drop the warning and turn it
>     to a hard error.
>
>     Best,
>
>     Paul
>
>     On 1/6/19 1:43 PM, Guido van Rossum wrote:
>>     I don't think datetime and builtins like int necessarily need to
>>     be aligned. But I do see a problem -- the __new__ and __init__
>>     methods defined in the subclass (if any) should allow for being
>>     called with the same signature as the base datetime class.
>>     Currently you can have a subclass of datetime whose __new__ has
>>     no arguments (or, more realistically, interprets its arguments
>>     differently). Instances of such a class can still be added to a
>>     timedelta. The proposal would cause this to break (since such an
>>     addition has to create a new instance, which calls __new__ and
>>     __init__). Since this is a backwards incompatibility, I don't see
>>     how it can be done -- and I also don't see many use cases, so I
>>     think it's not worth pursuing further.
>>
>>     Note that the same problem already happens with the
>>     .fromordinal() class method, though it doesn't happen with
>>     .fromdatetime() or .now():
>>
>>     >>> class D(datetime.datetime):
>>     ...?? def __new__(cls): return cls.now()
>>     ...
>>     >>> D()
>>     D(2019, 1, 6, 10, 33, 37, 161606)
>>     >>> D.fromordinal(100)
>>     Traceback (most recent call last):
>>     ? File "<stdin>", line 1, in <module>
>>     TypeError: __new__() takes 1 positional argument but 4 were given
>>     >>> D.fromtimestamp(123456789)
>>     D(1973, 11, 29, 13, 33, 9)
>>     >>>
>>
>>     On Sun, Jan 6, 2019 at 9:05 AM Paul Ganssle <paul at ganssle.io
>>     <mailto:paul at ganssle.io>> wrote:
>>
>>         I can think of many reasons why datetime is different from
>>         builtins, though to be honest I'm not sure that consistency
>>         for its own sake is really a strong argument for keeping a
>>         counter-intuitive behavior - and to be honest I'm open to the
>>         idea that /all/ arithmetic types /should/ have some form of
>>         this change.
>>
>>         That said, I would say that the biggest difference between
>>         datetime and builtins (other than the fact that datetime is
>>         /not/ a builtin, and as such doesn't necessarily need to be
>>         categorized in this group), is that unlike almost all other
>>         arithmetic types, /datetime/ has a special, dedicated type
>>         for describing differences in datetimes. Using your example
>>         of a float subclass, consider that without the behavior of
>>         "addition of floats returns floats", it would be hard to
>>         predict what would happen in this situation:
>>
>>         >>> F(1.2) + 3.4
>>
>>         Would that always return a float, even though F(1.2) + F(3.4)
>>         returns an F? Would that return an F because F is the
>>         left-hand operand? Would it return a float because float is
>>         the right-hand operand? Would you walk the MROs and find the
>>         lowest type in common between the operands and return that?
>>         It's not entirely clear which subtype predominates. With
>>         datetime, you have:
>>
>>         datetime - datetime -> timedelta
>>         datetime ? timedelta -> datetime
>>         timedelta ? timedelta -> timedelta
>>
>>         There's no operation between two datetime objects that would
>>         return a datetime object, so it's always clear: operations
>>         between datetime subclasses return timedelta, operations
>>         between a datetime object and a timedelta return the subclass
>>         of the datetime that it was added to or subtracted from.
>>
>>         Of course, the real way to resolve whether datetime should be
>>         different from int/float/string/etc is to look at why this
>>         choice was actually made for those types in the first place,
>>         and decide whether datetime is like them /in this respect/.
>>         The heterogeneous operations problem may be a reasonable
>>         justification for leaving the other builtins alone but
>>         changing datetime, but if someone knows of other fundamental
>>         reasons why the decision to have arithmetic operations always
>>         create the base class was chosen, please let me know.
>>
>>         Best,
>>         Paul
>>
>>         On 1/5/19 3:55 AM, Alexander Belopolsky wrote:
>>>
>>>
>>>         On Wed, Jan 2, 2019 at 10:18 PM Paul Ganssle
>>>         <paul at ganssle.io <mailto:paul at ganssle.io>> wrote:
>>>
>>>             .. the original objection was that this implementation
>>>             assumes that the datetime subclass has a constructor
>>>             with the same (or a sufficiently similar) signature as
>>>             datetime.
>>>
>>>         While this was used as a possible rationale for the way
>>>         standard types behave, the main objection to changing
>>>         datetime classes is that it will make them behave
>>>         differently from builtins.? For example:
>>>
>>>         >>> class F(float):
>>>         ...? ? ?pass
>>>         ...
>>>         >>> type(F.fromhex('AA'))
>>>         <class '__main__.F'>
>>>         >>> type(F(1) + F(2))
>>>         <class 'float'>
>>>
>>>             This may be a legitimate gripe, but unfortunately that
>>>             ship has sailed long ago. All of datetime's alternate
>>>             constructors make this assumption. Any subclass that
>>>             does not meet this requirement must have worked around
>>>             it long ago (or they don't care about alternate
>>>             constructors).
>>>
>>>
>>>         This is right, but the same argument is equally applicable
>>>         to int, float, etc. subclasses.? If you want to limit your
>>>         change to datetime types you should explain what makes these
>>>         types special.??
>>         _______________________________________________
>>         Python-Dev mailing list
>>         Python-Dev at python.org <mailto:Python-Dev at python.org>
>>         https://mail.python.org/mailman/listinfo/python-dev
>>         Unsubscribe:
>>         https://mail.python.org/mailman/options/python-dev/guido%40python.org
>>
>>
>>
>>     -- 
>>     --Guido van Rossum (python.org/~guido <http://python.org/~guido>)
>     _______________________________________________
>     Python-Dev mailing list
>     Python-Dev at python.org <mailto:Python-Dev at python.org>
>     https://mail.python.org/mailman/listinfo/python-dev
>     Unsubscribe:
>     https://mail.python.org/mailman/options/python-dev/brett%40python.org
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.python.org/pipermail/python-dev/attachments/20190106/3463db7e/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: OpenPGP digital signature
URL: <http://mail.python.org/pipermail/python-dev/attachments/20190106/3463db7e/attachment-0001.sig>

From guido at python.org  Sun Jan  6 19:17:14 2019
From: guido at python.org (Guido van Rossum)
Date: Sun, 6 Jan 2019 16:17:14 -0800
Subject: [Python-Dev] Return type of datetime subclasses added to
 timedelta
In-Reply-To: <2415dd60-b6b4-30b0-90d2-c0c8b22314c7@ganssle.io>
References: <1059740e-cc65-205d-5986-a9397463a315@ganssle.io>
 <CAP7h-xa-Dp8TXrm7Oa=jDwf0wyBfVy-6zK08w219q0jVaYACiQ@mail.gmail.com>
 <bb5120e0-159e-106d-04c6-2a15f7398966@ganssle.io>
 <CAP7+vJL3JrRFstg_QNdq5C4kHkxdsbKyACJBxWSPUbyuTjao3g@mail.gmail.com>
 <2415dd60-b6b4-30b0-90d2-c0c8b22314c7@ganssle.io>
Message-ID: <CAP7+vJKbQeTgROAtNLvXMwK5xjO8V=pCCs-CHpGAnt+G5TZcyg@mail.gmail.com>

OK, I concede your point (and indeed I only tested this on 3.6). If we
could break the backward compatibility for now() we presumably can break it
for this purpose.

On Sun, Jan 6, 2019 at 11:02 AM Paul Ganssle <paul at ganssle.io> wrote:

> I did address this in the original post - the assumption that the subclass
> constructor will have the same arguments as the base constructor is baked
> into many alternate constructors of datetime. I acknowledge that this is a
> breaking change, but it is a small one - anyone creating such a subclass
> that *cannot* handled the class being created this way would be broken in
> myriad ways.
>
> We have also in recent years changed several alternate constructors
> (including `replace`) to retain the original subclass, which by your same
> standard would be a breaking change. I believe there have been no
> complaints. In fact, between Python 3.6 and 3.7, the very example you
> showed broke:
>
> Python 3.6.6:
>
> >>> class D(datetime.datetime):
> ...     def __new__(cls):
> ...         return cls.now()
> ...
> >>> D()
> D(2019, 1, 6, 13, 49, 38, 842033)
>
> Python 3.7.2:
>
> >>> class D(datetime.datetime):
> ...     def __new__(cls):
> ...         return cls.now()
> ...
> >>> D()
> Traceback (most recent call last):
>   File "<stdin>", line 1, in <module>
>   File "<stdin>", line 3, in __new__
> TypeError: __new__() takes 1 positional argument but 9 were given
>
>
> We haven't seen any bug reports about this sort of thing; what we *have*
> been getting is bug reports that subclassing datetime doesn't retain the
> subclass in various ways (because people *are* using datetime
> subclasses). This is likely to cause very little in the way of problems,
> but it will improve convenience for people making datetime subclasses and
> almost certainly performance for people using them (e.g. pendulum and
> arrow, which now need to take a slow pure python route in many situations
> to work around this problem).
>
> If we're *really* concerned with this backward compatibility breaking, we
> could do the equivalent of:
>
> try:
>     return new_behavior(...)
> except TypeError:
>     warnings.warn("The semantics of timedelta addition have "
>                   "changed in a way that raises an error in "
>                   "this subclass. Please implement __add__ "
>                   "if you need the old behavior.", DeprecationWarning)
>
> Then after a suitable notice period drop the warning and turn it to a hard
> error.
>
> Best,
>
> Paul
> On 1/6/19 1:43 PM, Guido van Rossum wrote:
>
> I don't think datetime and builtins like int necessarily need to be
> aligned. But I do see a problem -- the __new__ and __init__ methods defined
> in the subclass (if any) should allow for being called with the same
> signature as the base datetime class. Currently you can have a subclass of
> datetime whose __new__ has no arguments (or, more realistically, interprets
> its arguments differently). Instances of such a class can still be added to
> a timedelta. The proposal would cause this to break (since such an addition
> has to create a new instance, which calls __new__ and __init__). Since this
> is a backwards incompatibility, I don't see how it can be done -- and I
> also don't see many use cases, so I think it's not worth pursuing further.
>
> Note that the same problem already happens with the .fromordinal() class
> method, though it doesn't happen with .fromdatetime() or .now():
>
> >>> class D(datetime.datetime):
> ...   def __new__(cls): return cls.now()
> ...
> >>> D()
> D(2019, 1, 6, 10, 33, 37, 161606)
> >>> D.fromordinal(100)
> Traceback (most recent call last):
>   File "<stdin>", line 1, in <module>
> TypeError: __new__() takes 1 positional argument but 4 were given
> >>> D.fromtimestamp(123456789)
> D(1973, 11, 29, 13, 33, 9)
> >>>
>
> On Sun, Jan 6, 2019 at 9:05 AM Paul Ganssle <paul at ganssle.io> wrote:
>
>> I can think of many reasons why datetime is different from builtins,
>> though to be honest I'm not sure that consistency for its own sake is
>> really a strong argument for keeping a counter-intuitive behavior - and to
>> be honest I'm open to the idea that *all* arithmetic types *should* have
>> some form of this change.
>>
>> That said, I would say that the biggest difference between datetime and
>> builtins (other than the fact that datetime is *not* a builtin, and as
>> such doesn't necessarily need to be categorized in this group), is that
>> unlike almost all other arithmetic types, *datetime* has a special,
>> dedicated type for describing differences in datetimes. Using your example
>> of a float subclass, consider that without the behavior of "addition of
>> floats returns floats", it would be hard to predict what would happen in
>> this situation:
>>
>> >>> F(1.2) + 3.4
>>
>> Would that always return a float, even though F(1.2) + F(3.4) returns an
>> F? Would that return an F because F is the left-hand operand? Would it
>> return a float because float is the right-hand operand? Would you walk the
>> MROs and find the lowest type in common between the operands and return
>> that? It's not entirely clear which subtype predominates. With datetime,
>> you have:
>>
>> datetime - datetime -> timedelta
>> datetime ? timedelta -> datetime
>> timedelta ? timedelta -> timedelta
>>
>> There's no operation between two datetime objects that would return a
>> datetime object, so it's always clear: operations between datetime
>> subclasses return timedelta, operations between a datetime object and a
>> timedelta return the subclass of the datetime that it was added to or
>> subtracted from.
>>
>> Of course, the real way to resolve whether datetime should be different
>> from int/float/string/etc is to look at why this choice was actually made
>> for those types in the first place, and decide whether datetime is like
>> them *in this respect*. The heterogeneous operations problem may be a
>> reasonable justification for leaving the other builtins alone but changing
>> datetime, but if someone knows of other fundamental reasons why the
>> decision to have arithmetic operations always create the base class was
>> chosen, please let me know.
>>
>> Best,
>> Paul
>> On 1/5/19 3:55 AM, Alexander Belopolsky wrote:
>>
>>
>>
>> On Wed, Jan 2, 2019 at 10:18 PM Paul Ganssle <paul at ganssle.io> wrote:
>>
>>> .. the original objection was that this implementation assumes that the
>>> datetime subclass has a constructor with the same (or a sufficiently
>>> similar) signature as datetime.
>>>
>> While this was used as a possible rationale for the way standard types
>> behave, the main objection to changing datetime classes is that it will
>> make them behave differently from builtins.  For example:
>>
>> >>> class F(float):
>> ...     pass
>> ...
>> >>> type(F.fromhex('AA'))
>> <class '__main__.F'>
>> >>> type(F(1) + F(2))
>> <class 'float'>
>>
>> This may be a legitimate gripe, but unfortunately that ship has sailed
>>> long ago. All of datetime's alternate constructors make this assumption.
>>> Any subclass that does not meet this requirement must have worked around it
>>> long ago (or they don't care about alternate constructors).
>>>
>>
>> This is right, but the same argument is equally applicable to int, float,
>> etc. subclasses.  If you want to limit your change to datetime types you
>> should explain what makes these types special.
>>
>> _______________________________________________
>> Python-Dev mailing list
>> Python-Dev at python.org
>> https://mail.python.org/mailman/listinfo/python-dev
>> Unsubscribe:
>> https://mail.python.org/mailman/options/python-dev/guido%40python.org
>>
>
>
> --
> --Guido van Rossum (python.org/~guido)
>
> _______________________________________________
> Python-Dev mailing list
> Python-Dev at python.org
> https://mail.python.org/mailman/listinfo/python-dev
> Unsubscribe:
> https://mail.python.org/mailman/options/python-dev/guido%40python.org
>


-- 
--Guido van Rossum (python.org/~guido)
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.python.org/pipermail/python-dev/attachments/20190106/fa3ba704/attachment.html>

From ltian6 at eng.ua.edu  Mon Jan  7 19:11:23 2019
From: ltian6 at eng.ua.edu (Tian, Liang)
Date: Tue, 8 Jan 2019 00:11:23 +0000
Subject: [Python-Dev] python subprocess module to submit a list of slurm
 sbatch jobs,
 each job use multiprocessing.Pool to run simulation on single compute node
 in cluster
Message-ID: <ede904dacb9e40a880f8a8c52c58e463@eng.ua.edu>

Dear Developers,
I have been working on a piece of code development that need your sincere help (three code file attached here).

I use run_slurm.py to use python subprocess module to submit multiple jobs to slurm cluster by invoking a sbatch file with a for loop to reach the following target:

1) create some environmental variables for job_slurm.py to run simulations (values of these environmental variables will change for each job with the for loop)

2) invoke submit_slurm.sh to submit a sbatch job that will run job_slurm.py

3) each job_slurm.py will use python multiprocess.Pool to run parallized simulations on each ./mod_bart.sh exeutable file (will run for a few hours) on a single compute node in cluster using all cores of this compute node

I get the following error all the time, could you provide some insights on how our implementation is wrong to achieve the desired goal:


Exception in thread Thread-3:
Traceback (most recent call last):
  File "/share/apps/python/2.7/lib/python2.7/threading.py", line 552, in __bootstrap_inner
    self.run()
  File "/share/apps/python/2.7/lib/python2.7/threading.py", line 505, in run
    self.__target(*self.__args, **self.__kwargs)
  File "/share/apps/python/2.7/lib/python2.7/multiprocessing/pool.py", line 347, in _handle_results
    task = get()
TypeError: ('__init__() takes at least 3 arguments (1 given)', <class 'subprocess.CalledProcessError'>, ())


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.python.org/pipermail/python-dev/attachments/20190108/7117a0e8/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: run_slurm.py
Type: text/x-python-script
Size: 2268 bytes
Desc: run_slurm.py
URL: <http://mail.python.org/pipermail/python-dev/attachments/20190108/7117a0e8/attachment.bin>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: submit_slurm.sh
Type: text/x-sh
Size: 133 bytes
Desc: submit_slurm.sh
URL: <http://mail.python.org/pipermail/python-dev/attachments/20190108/7117a0e8/attachment.sh>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: job_slurm.py
Type: text/x-python-script
Size: 1055 bytes
Desc: job_slurm.py
URL: <http://mail.python.org/pipermail/python-dev/attachments/20190108/7117a0e8/attachment-0001.bin>

From steve at pearwood.info  Mon Jan  7 20:06:03 2019
From: steve at pearwood.info (Steven D'Aprano)
Date: Tue, 8 Jan 2019 12:06:03 +1100
Subject: [Python-Dev] python subprocess module to submit a list of slurm
 sbatch jobs,
 each job use multiprocessing.Pool to run simulation on single compute node
 in cluster
In-Reply-To: <ede904dacb9e40a880f8a8c52c58e463@eng.ua.edu>
References: <ede904dacb9e40a880f8a8c52c58e463@eng.ua.edu>
Message-ID: <20190108010603.GN13616@ando.pearwood.info>

This mailing list is for the development of the Python interpreter, not 
for asking questions about your own code.

Did you sign up using the Python-Dev mailing list website? At the top of 
the page, it says

    Do not post general Python questions to this list. For help with 
    Python please see the Python help page.

in bold and highlighted in red. Is this message not clear enough? How 
can we make it clearer?

For help debugging your code, you can try the resources here:

https://www.python.org/about/help/

or this mailing list: 

https://mail.python.org/mailman/listinfo/python-list

or here:

https://www.reddit.com/r/learnpython/


Thank you.


-- 
Steve

From aman30894 at gmail.com  Tue Jan  8 03:05:29 2019
From: aman30894 at gmail.com (Aman Agrawal)
Date: Tue, 8 Jan 2019 13:35:29 +0530
Subject: [Python-Dev] How can i insert more than 32K data to a column type
 clob in db2 using python programming
Message-ID: <CAB_3DMrLd++-LeWCdXYSK9m=vUu1XLmJQdaDFGfch7h8GCm_pg@mail.gmail.com>

 Hi Team,

I have tried to insert in clob data type more than 32k byte data but
getting error:-

Statement Execute Failed: [IBM][CLI Driver][DB2/LINUXX8664] SQL0102N  The
string constant beginning with "\'<p>Hi good day team:<br /> We had been
requested to Add Anniel to all" is too long.  SQLSTATE=54002 SQLCODE=-102

could any one please help me is there any way i can achieve it?

Please find my DDL statement:-

CREATE TABLE "DB2IDEV "."CHANGE"  (
          "TICKET_ID" INTEGER NOT NULL ,
          "SHORTDESC" VARCHAR(5000 OCTETS) NOT NULL ,
          "LONGDESC" CLOB(2147483647 OCTETS) LOGGED NOT COMPACT ,
          "RELEASENUM" VARCHAR(12 OCTETS) WITH DEFAULT NULL ,
          "ISSOFTDELETED" INTEGER NOT NULL WITH DEFAULT 0 ,
          "CREATETIMESTAMP" TIMESTAMP NOT NULL WITH DEFAULT CURRENT
TIMESTAMP ,
          "LASTUPDATETIMESTAMP" TIMESTAMP WITH DEFAULT NULL )
         IN "TABLESPACE"
         ORGANIZE BY ROW  ;

 conn =
db.connect("DATABASE=%s;HOSTNAME=%s;PORT=60001;PROTOCOL=TCPIP;UID=%s;PWD=%s;"%(DB2_DATABASE,DB2_HOSTNAME,DB2_UID,DB2_PWD),
"", "")
cursor = conn.cursor()

sql="INSERT INTO Change
(Ticket_ID,shortDesc,longDesc,releaseNum,isSoftDeleted,createTimeStamp,lastUpdateTimeStamp)
VALUES ('296129','High Cisco Adaptive Security Appliance Remote Code
Execution and Denial of Service Vulnerabilit','<Some long data around
50KB>',NULL,'0','2018-02-07 02:11:50',NULL)"

cursor.execute(sql)
conn.commit()

Thanks & Regards

*Aman Agrawal*
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.python.org/pipermail/python-dev/attachments/20190108/122fd3fe/attachment.html>

From steve at pearwood.info  Tue Jan  8 11:09:22 2019
From: steve at pearwood.info (Steven D'Aprano)
Date: Wed, 9 Jan 2019 03:09:22 +1100
Subject: [Python-Dev] How can i insert more than 32K data to a column
 type clob in db2 using python programming
In-Reply-To: <CAB_3DMrLd++-LeWCdXYSK9m=vUu1XLmJQdaDFGfch7h8GCm_pg@mail.gmail.com>
References: <CAB_3DMrLd++-LeWCdXYSK9m=vUu1XLmJQdaDFGfch7h8GCm_pg@mail.gmail.com>
Message-ID: <20190108160919.GR13616@ando.pearwood.info>

On Tue, Jan 08, 2019 at 01:35:29PM +0530, Aman Agrawal wrote:
>  Hi Team,
> 
> I have tried to insert in clob data type more than 32k byte data but
> getting error:-

This mailing list is for the development of the Python interpreter, not
for asking questions about your own code.

Did you sign up using the Python-Dev mailing list website? At the top of
the page, it says

    Do not post general Python questions to this list. For help with
    Python please see the Python help page.

in bold and highlighted in red. Is this message not clear enough? How
can we make it clearer?

For help debugging your code, you can try the resources here:

https://www.python.org/about/help/

or this mailing list:

https://mail.python.org/mailman/listinfo/python-list

or here:

https://www.reddit.com/r/learnpython/


Thank you.


--
Steve

