From k.kowitski at icloud.com  Sat Sep  1 12:32:15 2018
From: k.kowitski at icloud.com (Kevin Kowitski)
Date: Sat, 01 Sep 2018 12:32:15 -0400
Subject: [Python-Dev] New Subscriber
Message-ID: <CC776CA1-2AA1-417C-AC13-6D4FE29D9399@icloud.com>

Hey Everyone! 

   I am new to this mailing list. I have experience with software development in the medical device industry and SaaS technology solutions. I have primarily worked with R, Java, and various unique and specific machine languages, but I have recently picked up Python. 
   Part of what has brought me to this mailing list was my search for insights on Python?s usability as a shareable, executable, desktop application. I often make tools for streamlining my professional tasks and decided I wanted to give Python a try. I have read that there are some fantastic GUI libraries and development environments, but how practical is this language for distributing those programs in a nicely packaged exe? 
    If there is anyone here with some insight I would love to start off my membership with a discussion and some knowledge sharing!

Best,
Kevin

Sent from my iPhone

From brett at python.org  Sat Sep  1 13:48:58 2018
From: brett at python.org (Brett Cannon)
Date: Sat, 1 Sep 2018 10:48:58 -0700
Subject: [Python-Dev] New Subscriber
In-Reply-To: <CC776CA1-2AA1-417C-AC13-6D4FE29D9399@icloud.com>
References: <CC776CA1-2AA1-417C-AC13-6D4FE29D9399@icloud.com>
Message-ID: <CAP1=2W6ShnDxw6hWnVV6y_HwAUA4AK46zRgjVbXL+XuSvrn5wg@mail.gmail.com>

Hi, Kevin! This mailing list is actually about the development *of* Python,
not *with* it. To have a discussion about GUI programming with Python is
probably python-list is a better place to discuss this.

On Sat, 1 Sep 2018 at 10:37 Kevin Kowitski via Python-Dev <
python-dev at python.org> wrote:

> Hey Everyone!
>
>    I am new to this mailing list. I have experience with software
> development in the medical device industry and SaaS technology solutions. I
> have primarily worked with R, Java, and various unique and specific machine
> languages, but I have recently picked up Python.
>    Part of what has brought me to this mailing list was my search for
> insights on Python?s usability as a shareable, executable, desktop
> application. I often make tools for streamlining my professional tasks and
> decided I wanted to give Python a try. I have read that there are some
> fantastic GUI libraries and development environments, but how practical is
> this language for distributing those programs in a nicely packaged exe?
>     If there is anyone here with some insight I would love to start off my
> membership with a discussion and some knowledge sharing!
>
> Best,
> Kevin
>
> Sent from my iPhone
> _______________________________________________
> Python-Dev mailing list
> Python-Dev at python.org
> https://mail.python.org/mailman/listinfo/python-dev
> Unsubscribe:
> https://mail.python.org/mailman/options/python-dev/brett%40python.org
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.python.org/pipermail/python-dev/attachments/20180901/0b48d178/attachment.html>

From aixtools at felt.demon.nl  Sat Sep  1 13:55:42 2018
From: aixtools at felt.demon.nl (Michael)
Date: Sat, 1 Sep 2018 19:55:42 +0200
Subject: [Python-Dev] make patchcheck and git path
In-Reply-To: <23429.93.348012.547338@turnbull.sk.tsukuba.ac.jp>
References: <5f9b58cd-224a-6851-0bd0-54a2731aa9e4@felt.demon.nl>
 <CAGbohnZXazy1PxA39mxzzxrRhp9n_8ouUpDz7CZr_f2VXzCKMw@mail.gmail.com>
 <F8F7381B-EAC5-47EA-8153-7F45512A8ECB@felt.demon.nl>
 <23429.93.348012.547338@turnbull.sk.tsukuba.ac.jp>
Message-ID: <174f24fe-18e5-4a7e-b03f-245c78ab38ca@felt.demon.nl>

On 28/08/2018 09:57, Stephen J. Turnbull wrote:
> Michael Felt (aixtools) writes:
>
>  > When building out of tree there is no .git reference. If I
>  > understand the process it uses git to see what files have changed,
>  > and does further processing on those.
>
> Just guessing based on generic git knowledge here:
>
> If you build in a sibling directory of the .git directory, git should
> "see" the GITDIR, and it should work.  Where is your build directory
> relative to the GITDIR?
I work in "parallel"
/data/prj/python/python-version
/data/prj/python/git/python-version

I suppose I should try setting GITDIR - but, I think it would be better,
at least nicer, if "patchcheck" as a target did some checking for git
early on, rather than bail out at the end. The results of the check
might be just a message to set GITDIR, e.g..
> I suspect you could also set GITDIR=/path/to/python/source/.git in
> make's process environment, and do "make patchcheck" outside of the
> Python source tree successfully.
I'll give this a try next time around. (vacation, so not really 'active'
atm).

Thanks for the suggestions.
>
> Regards,
>


-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: OpenPGP digital signature
URL: <http://mail.python.org/pipermail/python-dev/attachments/20180901/45811506/attachment.sig>

From k.kowitski at icloud.com  Sat Sep  1 14:12:02 2018
From: k.kowitski at icloud.com (Kevin Kowitski)
Date: Sat, 01 Sep 2018 14:12:02 -0400
Subject: [Python-Dev] New Subscriber
In-Reply-To: <CAP1=2W6ShnDxw6hWnVV6y_HwAUA4AK46zRgjVbXL+XuSvrn5wg@mail.gmail.com>
References: <CC776CA1-2AA1-417C-AC13-6D4FE29D9399@icloud.com>
 <CAP1=2W6ShnDxw6hWnVV6y_HwAUA4AK46zRgjVbXL+XuSvrn5wg@mail.gmail.com>
Message-ID: <AF13D162-D9D9-4573-8FEE-BB715DFB7C22@icloud.com>

Oh!  I?m so sorry haha. I thought this was a developers forum for users of Python. So you are saying Python-list would be that type of forum? 

-Kevin

Sent from my iPhone

> On Sep 1, 2018, at 1:48 PM, Brett Cannon <brett at python.org> wrote:
> 
> Hi, Kevin! This mailing list is actually about the development of Python, not with it. To have a discussion about GUI programming with Python is probably python-list is a better place to discuss this.
> 
>> On Sat, 1 Sep 2018 at 10:37 Kevin Kowitski via Python-Dev <python-dev at python.org> wrote:
>> Hey Everyone! 
>> 
>>    I am new to this mailing list. I have experience with software development in the medical device industry and SaaS technology solutions. I have primarily worked with R, Java, and various unique and specific machine languages, but I have recently picked up Python. 
>>    Part of what has brought me to this mailing list was my search for insights on Python?s usability as a shareable, executable, desktop application. I often make tools for streamlining my professional tasks and decided I wanted to give Python a try. I have read that there are some fantastic GUI libraries and development environments, but how practical is this language for distributing those programs in a nicely packaged exe? 
>>     If there is anyone here with some insight I would love to start off my membership with a discussion and some knowledge sharing!
>> 
>> Best,
>> Kevin
>> 
>> Sent from my iPhone
>> _______________________________________________
>> Python-Dev mailing list
>> Python-Dev at python.org
>> https://mail.python.org/mailman/listinfo/python-dev
>> Unsubscribe: https://mail.python.org/mailman/options/python-dev/brett%40python.org
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.python.org/pipermail/python-dev/attachments/20180901/30784c45/attachment.html>

From brett at python.org  Sat Sep  1 14:23:20 2018
From: brett at python.org (Brett Cannon)
Date: Sat, 1 Sep 2018 11:23:20 -0700
Subject: [Python-Dev] New Subscriber
In-Reply-To: <AF13D162-D9D9-4573-8FEE-BB715DFB7C22@icloud.com>
References: <CC776CA1-2AA1-417C-AC13-6D4FE29D9399@icloud.com>
 <CAP1=2W6ShnDxw6hWnVV6y_HwAUA4AK46zRgjVbXL+XuSvrn5wg@mail.gmail.com>
 <AF13D162-D9D9-4573-8FEE-BB715DFB7C22@icloud.com>
Message-ID: <CAP1=2W6J36QqLHBH+OW+TXgPTuKk6UyK_zS56ih+TqKRqm33DQ@mail.gmail.com>

Yep, python-list sounds like the mailing list that you're after.

On Sat, 1 Sep 2018 at 11:12 Kevin Kowitski <k.kowitski at icloud.com> wrote:

> Oh!  I?m so sorry haha. I thought this was a developers forum for users of
> Python. So you are saying Python-list would be that type of forum?
>
> -Kevin
>
> Sent from my iPhone
>
> On Sep 1, 2018, at 1:48 PM, Brett Cannon <brett at python.org> wrote:
>
> Hi, Kevin! This mailing list is actually about the development *of*
> Python, not *with* it. To have a discussion about GUI programming with
> Python is probably python-list is a better place to discuss this.
>
> On Sat, 1 Sep 2018 at 10:37 Kevin Kowitski via Python-Dev <
> python-dev at python.org> wrote:
>
>> Hey Everyone!
>>
>>    I am new to this mailing list. I have experience with software
>> development in the medical device industry and SaaS technology solutions. I
>> have primarily worked with R, Java, and various unique and specific machine
>> languages, but I have recently picked up Python.
>>    Part of what has brought me to this mailing list was my search for
>> insights on Python?s usability as a shareable, executable, desktop
>> application. I often make tools for streamlining my professional tasks and
>> decided I wanted to give Python a try. I have read that there are some
>> fantastic GUI libraries and development environments, but how practical is
>> this language for distributing those programs in a nicely packaged exe?
>>     If there is anyone here with some insight I would love to start off
>> my membership with a discussion and some knowledge sharing!
>>
>> Best,
>> Kevin
>>
>> Sent from my iPhone
>> _______________________________________________
>> Python-Dev mailing list
>> Python-Dev at python.org
>> https://mail.python.org/mailman/listinfo/python-dev
>> Unsubscribe:
>> https://mail.python.org/mailman/options/python-dev/brett%40python.org
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.python.org/pipermail/python-dev/attachments/20180901/53031398/attachment.html>

From stefan_ml at behnel.de  Sat Sep  1 18:10:31 2018
From: stefan_ml at behnel.de (Stefan Behnel)
Date: Sun, 2 Sep 2018 00:10:31 +0200
Subject: [Python-Dev] Use of Cython
In-Reply-To: <CA+St6D1DNV3j9ieH-M9X0mkMH5mAXKYYOqBeDUWT952ZkCdNyA@mail.gmail.com>
References: <CA+3bQGFzxdS=eBOyMWT-yHnP4pV=EukkbYKue6nPaAKk4713=w@mail.gmail.com>
 <20180730110120.6d03e6d8@fsol>
 <CA+3bQGGHjPJv6aL4t0T7iy9DGAc1xXSm+b_qxawEv=E2H_zoWw@mail.gmail.com>
 <74a848fa0eff42fc8ae5aa58e3fe71d0@xmail101.UGent.be>
 <5B600F47.3090503@UGent.be> <20180731094528.118471f9@fsol>
 <CADiSq7dKDSq7VsejP_FTDrSmvmeRcQmSD5OaVFO9qkwybtJqDg@mail.gmail.com>
 <17ebc01b-e0f2-1ebc-1229-b4ca84843f9c@python.org>
 <pk4e46$q92$1@blaine.gmane.org>
 <CADiSq7cKqgw=-AjDKCQ9QzGCN5yHOA+353cjkZvmdVvYN5qZpw@mail.gmail.com>
 <8CA25A41-D9F4-4634-9509-604F84B09E46@mac.com>
 <CADiSq7f0+CosMD5n2Ybbu90rQcJXq4Ska7KUn9smeaL=1XuMmA@mail.gmail.com>
 <2B17179F-29B4-40E2-824D-749359E33089@mac.com>
 <pk9oev$eh3$1@blaine.gmane.org>
 <57363ED3-4851-4A5D-A4B9-F9F0A9053F2C@mac.com>
 <CA+St6D1DNV3j9ieH-M9X0mkMH5mAXKYYOqBeDUWT952ZkCdNyA@mail.gmail.com>
Message-ID: <pmf2kk$adv$1@blaine.gmane.org>

Yury,

given that people are starting to quote enthusiastically the comments you
made below, let me set a couple of things straight.

Yury Selivanov schrieb am 07.08.2018 um 19:34:
> On Mon, Aug 6, 2018 at 11:49 AM Ronald Oussoren via Python-Dev wrote:
> 
>> I have no strong opinion on using Cython for tests or in the stdlib, other than that it is a fairly large dependency.  I do think that adding a ?Cython-lite? tool the CPython distribution would be less ideal, creating and maintaining that tool would be a lot of work without clear benefits over just using Cython.
> 
> Speaking of which, Dropbox is working on a new compiler they call "mypyc".
> 
> mypyc will compile type-annotated Python code to an optimized C.

That's their plan. Saying that "it will" is a bit premature at this point.
The list of failed attempts at writing static Python compilers is rather
long, even if you only count those that compile the usual "easy subset" of
Python.

I wish them the best of luck and endurance, but they have a long way to go.


> The
> first goal is to compile mypy with it to make it faster, so I hope
> that the project will be completed.

That's not "the first goal". It's the /only/ goal. The only intention of
mypyc is to be able to compile and optimise enough of Python to speed up
the kind or style of code that mypy uses.


> Essentially, mypyc will be similar
> to Cython, but mypyc is a *subset of Python*, not a superset.

Which is bad, right? It means that there will be many things that simply
don't work, and that you need to change your code in order to make it
compile at all. Cython is way beyond that point by now. Even RPython will
probably continue to be way better than mypyc for quite a while, maybe
forever, who knows.


> Interfacing with C libraries can be easily achieved with cffi.

Except that it will be fairly slow. cffi is not designed for static
analysis but for runtime operations. You can obviously also use cffi from
Cython ? but then, why would you, if you can get much faster code much more
easily without using cffi?

That being said, if someone wants to write a static cffi optimiser for
Cython, why not, I'd be happy to help with my advice. The cool thing is
that this can be improved gradually, because compiling the cffi code
probably already works out of the box. It's just not (much) faster than
when interpreted.


> Being a
> strict subset of Python means that mypyc code will execute just fine
> in PyPy.

So does normal (non-subset) Python code. You can run it in PyPy, have
CPython interpret it, or compile it with Cython if you want it to run
faster in CPython, all without having to limit yourself to a subset of
Python. Seriously, you make this sound like requiring users to rewrite
their code to make it compilable with mypyc was a good thing.


> They can even apply some optimizations to it eventually, as
> it has a strict and static type system.

In case "they" refers to PyPy here, then I remember the PyPy project
stating very clearly that they are not interested in PEP-484 typing because
it is completely irrelevant for their JIT. It's really best for them to
ignore it.

That's similar for Cython, simply because PEP-484 typing isn't designed for
optimisation at all, definitely not for C-level optimisation. Still, Cython
can make some use of PEP-484 typing, if you use it to define specific C
types. That allows normal execution in CPython, static analysis with
PEP-484 analyser tools (e.g. PyCharm or mypy), and efficient optimisation
by Cython. The best of all worlds. See the docs on how to do that, it's
been supported for about a year now (and has been around in a similar,
non-PEP-484 form for years before that PEP even existed).


> I'd be more willing to start using mypyc+cffi in CPython stdlib
> *eventually*, than Cython now.  Cython is a relatively complex and
> still poorly documented language.

You are free to improve the documentation or otherwise help us find and
discuss concrete problems with it. Calling Cython a "poorly documented
language" could easily feel offensive towards those who have put a lot of
work into the documentation, wiki, tutorials, trainings and what not that
help people use the language. Even stack overflow is getting better and
better in documenting Cython these days, even though responses over there
that describe work-arounds tend to get outdated fairly quickly.

Besides, don't forget that it's Python, so consider reading the Python
documentation first if something is unclear. And maybe some documentation
of C data types as well. (.5 wink)


> I'm speaking from experience after
> writing thousands of lines of Cython in uvloop & asyncpg.  In skillful
> hands Cython is amazing, but I'd be cautious to advertise and use it
> in CPython.

Why not? You didn't actually give any reasons for that.


> I'm also -1 on using Cython to test C API. While writing C tests is
> annoying (I wrote a fair share myself), their very purpose is to make
> third-party tools/extensions more stable. Using a third-party tool to
> test C API to track regressions that break third-party tools feels
> wrong.

I don't understand that argument. What's wrong about using a tool that
helps you get around writing boiler plate code? The actual testing does not
need to be done by Cython at all, you can write it any way you like.

Stefan


From ncoghlan at gmail.com  Sun Sep  2 12:56:55 2018
From: ncoghlan at gmail.com (Nick Coghlan)
Date: Mon, 3 Sep 2018 02:56:55 +1000
Subject: [Python-Dev] UTF-8 Mode now also enabled by the POSIX locale
In-Reply-To: <CA+3bQGEUz-PATkcBkPUoxKKLe64YjQFukn8yB+zkHqOWm=QBUQ@mail.gmail.com>
References: <CA+3bQGEUz-PATkcBkPUoxKKLe64YjQFukn8yB+zkHqOWm=QBUQ@mail.gmail.com>
Message-ID: <CADiSq7d3PaOnBSaX0cNo7MhtjeObv8zvuPS-ySmhM4=6B5ZgGw@mail.gmail.com>

On Tue, 28 Aug 2018 at 23:02, Victor Stinner <vstinner at redhat.com> wrote:
>
> Hi,
>
> While working on test_utf8_mode on AIX (bpo-34347) and HP-UX
> (bpo-34403), I noticed that FreeBSD doesn't work properly with the
> POSIX locale (bpo-34527). I also noticed that my implementation of my
> PEP 540 "UTF-8 Mode" doesn't respect the PEP: the UTF-8 Mode should be
> enabled by the POSIX locale, not only by the C locale.
>
> I just modified Python 3.7 and master (future 3.8) to enable UTF-8
> Mode if the LC_CTYPE locale is "POSIX":
> https://bugs.python.org/issue34527
>
> I also fixed FreeBSD to support the "POSIX" locale as well (3.6, 3.7
> and master branches).
>
> Note: The C locale coercion (PEP 538) is only enabled if the LC_CTYPE
> locale is "C".

https://bugs.python.org/issue30672 is the open issue noting that it
should also handle the case where POSIX isn't a simple alias for the C
locale the way it is in glibc.

Cheers,
Nick.

-- 
Nick Coghlan   |   ncoghlan at gmail.com   |   Brisbane, Australia

From ncoghlan at gmail.com  Sun Sep  2 13:02:32 2018
From: ncoghlan at gmail.com (Nick Coghlan)
Date: Mon, 3 Sep 2018 03:02:32 +1000
Subject: [Python-Dev] AIX and python tests
In-Reply-To: <061047f4-6bbc-a662-412d-bb5febfc72bb@felt.demon.nl>
References: <061047f4-6bbc-a662-412d-bb5febfc72bb@felt.demon.nl>
Message-ID: <CADiSq7fDmcagQqLGS3E=L77bN-owmOcDCtWpFs5txBOY24dTyg@mail.gmail.com>

On Mon, 6 Aug 2018 at 07:03, Michael <aixtools at felt.demon.nl> wrote:
>
> As I have time, I'll dig into these.
>
> I have a couple of PR already 'out there', which I hope someone will be looking at when/as he/she/they have time. My time will also be intermittent.
>
> My next test - and I hope not too difficult - would be the test_utf8. The test:
>
> FAIL: test_cmd_line (test.test_utf8_mode.UTF8ModeTests)
>
> fails - and I am wondering if it is as simple as AIX default mode is ISO8559-1
> and the test looks to be comparing UTF8 with the locale_default.
> If that is the case, obviously this test will never succeed - asis.
>
> Am I understanding the test properly.
> If yes, then I'll see what I can come up with for a patch to the test for AIX.
> If no, I'll need some hand holding to help me understand the test

UTF-8 mode relates to PEP 540, and the intent is that the default
C/POSIX locale should either be coerced to a UTF-8 based one (by the
PEP 538 mechanism), or else UTF-8 mode will activate, and CPython will
set its *own* encoding to UTF-8, and ignore the locale one.

We did need to make the PEP 538 tests AIX-aware [1] so they knew what
to expect as the default encoding when locale coercion was disabled,
so it's possible some further special casing will be needed in the
UTF-8 mode tests as well.

Cheers,
Nick.

[1] https://github.com/python/cpython/blob/master/Lib/test/test_c_locale_coercion.py#L40

-- 
Nick Coghlan   |   ncoghlan at gmail.com   |   Brisbane, Australia

From cmawebsite at gmail.com  Sun Sep  2 17:37:59 2018
From: cmawebsite at gmail.com (Collin Anderson)
Date: Sun, 2 Sep 2018 17:37:59 -0400
Subject: [Python-Dev] Python 2.7 EOL date
In-Reply-To: <1535223033.3211797.1486041560.6B4E95EE@webmail.messagingengine.com>
References: <CAHp18wVsuAo_ev3PQtO13a6FAfXgxXmwE6wOmLxDsogT-k_BSw@mail.gmail.com>
 <1535223033.3211797.1486041560.6B4E95EE@webmail.messagingengine.com>
Message-ID: <CAHp18wUFGJjXS+hZmUhCLKKTRfGDaWieW8iGi8Ms_JnYyM+2tw@mail.gmail.com>

Thanks all for clarifying! -Collin

On Sat, Aug 25, 2018 at 2:50 PM Benjamin Peterson <benjamin at python.org>
wrote:

> I was operating under the optimistic assumption whatever the precise time
> of 2.7's official demise would only be an amusing piece of trivia for a
> world of happy Python 3 users.
>
> It's still to early to promise exact release dates; that will depend on
> the day-to-day schedules of the release manager and binary builders circa
> January 2020. A conservative assumption is that no 2.7 changes that land
> after December 31 2019 will ever be released.
>
> We could make the last release of 2.7 in July 2020. But what does that buy
> anyone?
>
> On Thu, Aug 23, 2018, at 11:53, Collin Anderson wrote:
> > Hi All,
> >
> > Sorry if this has been mentioned before, but I noticed the Python 2.7 EOL
> > date was recently set to Jan 1st, 2020.
> >
> > My understanding was Python releases get 5 years of support from their
> > initial release, and Python 2.7 was extended an additional 5 years.
> >
> > Python 2.7 was originally released on 2010-07-03, and with an original
> EOL
> > of 2015-07-03. Extended 5 years, shouldn't the EOL be 2020-07-03?
> >
> > Also, this statement is a little unclear to me:
> >
> > > Specifically, 2.7 will receive bugfix support until January 1, 2020.
> All
> > 2.7 development work will cease in 2020.
> >
> > This statement makes it sound like bugfixes end on Jan 1st, but seems to
> > leave open the possibility that security fixes could continue through the
> > year.
> >
> > Thanks!
> > Collin
> > _______________________________________________
> > Python-Dev mailing list
> > Python-Dev at python.org
> > https://mail.python.org/mailman/listinfo/python-dev
> > Unsubscribe:
> > https://mail.python.org/mailman/options/python-dev/benjamin%40python.org
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.python.org/pipermail/python-dev/attachments/20180902/14ab3604/attachment.html>

From talha.noyon10 at gmail.com  Mon Sep  3 11:43:35 2018
From: talha.noyon10 at gmail.com (Md Abu Talha)
Date: Mon, 3 Sep 2018 21:43:35 +0600
Subject: [Python-Dev] pyOpengl text render
Message-ID: <CAEGN3xq_5vdT1Y5s5jBOiSquXLo+Km-LRHfO+o2tSwE_mHvaUQ@mail.gmail.com>

How can I rendered text using python and opengl? please help
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.python.org/pipermail/python-dev/attachments/20180903/9499984d/attachment.html>

From phd at phdru.name  Mon Sep  3 12:24:40 2018
From: phd at phdru.name (Oleg Broytman)
Date: Mon, 3 Sep 2018 18:24:40 +0200
Subject: [Python-Dev] pyOpengl text render
In-Reply-To: <CAEGN3xq_5vdT1Y5s5jBOiSquXLo+Km-LRHfO+o2tSwE_mHvaUQ@mail.gmail.com>
References: <CAEGN3xq_5vdT1Y5s5jBOiSquXLo+Km-LRHfO+o2tSwE_mHvaUQ@mail.gmail.com>
Message-ID: <20180903162440.gxudwqfnsv2gjfff@phdru.name>

Hello.

   This mailing list is to work on developing Python (adding new
features to Python itself and fixing bugs); if you're having problems
learning, understanding or using Python, please find another forum.
Probably python-list/comp.lang.python mailing list/news group is the
best place; there are Python developers who participate in it; you may
get a faster, and probably more complete, answer there. See
https://www.python.org/community/ for other lists/news groups/fora.
Thank you for understanding.

On Mon, Sep 03, 2018 at 09:43:35PM +0600, Md Abu Talha <talha.noyon10 at gmail.com> wrote:
> How can I rendered text using python and opengl? please help

   https://www.google.com/search?hl=en&pws=0&q=python+opengl+render+text

   https://stackoverflow.com/search?q=%5Bpython%5D+%5Bopengl%5D+render+text

Oleg.
-- 
    Oleg Broytman            https://phdru.name/            phd at phdru.name
           Programmers don't die, they just GOSUB without RETURN.

From oono0114 at gmail.com  Tue Sep  4 10:37:23 2018
From: oono0114 at gmail.com (=?UTF-8?B?5aSn6YeO6ZqG5byY?=)
Date: Tue, 4 Sep 2018 23:37:23 +0900
Subject: [Python-Dev] AES cipher implementation in standard library
Message-ID: <CAKyqbBqHOR7zuQ0ZPYSfB5H0U5Z3WRmmuZr5-Rf7Yf6d2zv-7g@mail.gmail.com>

Dear all,

Have we tried cipher implementation includes AES as a standard library in
the past?
https://docs.python.org/3.6/library/crypto.html

if possible I want to try to implement AES because famous 3rd party library
is not maintained and general cipher programs should be used for multiple
purpose.Though the implementation is tough,  I believe this should be worth
to it.
In my case, I want to use AES implementation for zipfile module.

Thanks and Regards,
---------------
Takahiro Ono
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.python.org/pipermail/python-dev/attachments/20180904/04e442d5/attachment.html>

From oono0114 at gmail.com  Tue Sep  4 10:43:27 2018
From: oono0114 at gmail.com (=?UTF-8?B?5aSn6YeO6ZqG5byY?=)
Date: Tue, 4 Sep 2018 23:43:27 +0900
Subject: [Python-Dev] Cipher implementation (such as AES) in standard library
Message-ID: <CAKyqbBpReZ5-cYAnW2ETCArjBB6mjYXR7cFw5c-+VTUn0sMeuA@mail.gmail.com>

Dear all,

Have we tried cipher implementation includes AES as a standard library in
the past?
https://docs.python.org/3.6/library/crypto.html

if possible I want to try to implement AES because famous 3rd party library
is not maintained and general cipher programs should be used for multiple
purpose.Though the implementation is tough,  I believe this should be worth
to it.
In my case, I want to use AES implementation for zipfile module.

Thanks and Regards,
---------------
Takahiro Ono
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.python.org/pipermail/python-dev/attachments/20180904/a0a4bcab/attachment.html>

From eelizondo at fb.com  Tue Sep  4 11:13:54 2018
From: eelizondo at fb.com (Eddie Elizondo)
Date: Tue, 4 Sep 2018 15:13:54 +0000
Subject: [Python-Dev] Heap-allocated StructSequences
Message-ID: <EA6CC3C2-A371-4F24-AF5C-4401B57ED487@fb.com>

PEP-384 talks about defining a Stable ABI by making PyTypeObject opaque. Thus, banning the use of static PyTypeObjects.

Specifically, I?d like to focus on those static PyTypeObjects that are initialized as StructSequences. As of today, there are 14 instances of these types (in timemodule.c, posixmodule.c, etc.) within cpython/Modules. These are all initialized through PyStructSequence_InitType2. This is very problematic when trying to make these types conform to PEP-384 as they are used through static PyTypeObjects.

Problems:

  *   PyStructSequence_InitType2 overrides the PyTypeObject:

This C-API does a direct memcpy from a ?prototype? structure. This effectively overrides anything set within the PyTypeObject. For example, if we were to initialize a heap allocated PyTypeObject and pass it on to this function, the C-API would just get rid of the Py_TPFLAG_HEAPTYPE flag, causing issues with the GC.


  *   PyStructSequence_InitType2 does not work with heap allocated PyTypeObjects:

Even if the function is fixed to preserve the state of the PyTypeObject and only overriding the specific slots (i.e. tp_new, tp_repr, etc.), it is expected that PyStructSequence_InitType2 will call PyType_Ready on the object. That means that the incoming object shouldn?t be initialized by a function such as PyType_FromSpec, as that would have already called PyType_Ready on it. Therefore, PyStructSequence_InitType2 will now have the responsibility of setting all the slots and properties of the PyHeapTypeObject, which is not feasible.


  *   PyStructSequence_NewType is non-functional:

This function was meant to be used as a way of creating a heap-allocated PyTypeObject that be passed to PyStructSequence_InitType2, effectively returning a heap allocated PyTypeObject. The current implementation doesn?t work in practice. Given that this struct is created in the heap, the GC has control over it. Thus, when the GC tries to traverse the type it complains with: ?Error: type_traverse() called for non-heap type?, since it doesn?t have the Py_TPFLAG_HEAPTYPE flag. If we add the flag, we run into bullet point 1, if we are able to preserve the flag then we will still run into the problem of bullet point 2. Extra note: This C-API is not being used anywhere within CPython itself.

Solution:

  *   Fix the implementation of PyStructSequence_NewType:

The best solution would be to fix the implementation of this function. This can easily be done by dynamically creating a PyType_Spec and calling PyType_FromSpec

```

PyObject*

PyStructSequence_NewType(PyStructSequence_Desc *desc)

{

    // ?

    PyType_Spec* spec = PyMem_NEW(PyType_Spec, 1);

    spec->name = desc->name;

    spec->basicsize = sizeof(PyStructSequence) - sizeof(PyObject *);

    spec->itemsize = sizeof(PyObject *);

    spec->flags = Py_TPFLAGS_DEFAULT;

    spec->slots = PyMem_NEW(PyType_Slot, 6);

    spec->slots[0].slot = Py_tp_dealloc;

    spec->slots[0].pfunc = (destructor)structseq_dealloc;

    // ?

    bases = PyTuple_Pack(1, &PyTuple_Type);

   type = PyType_FromSpecWithBases(spec, bases);

    // ?

```



This will cleanly create a heap allocated PyStructSequence which can be used just like any stack allocated PyTypeObject initialized through PyStructSequence_InitType2. This means that any C-Extension should be using PyStructSequence_NewType and only built-in types should be calling PyStructSequence_InitType2. This will enable these types to comply with PEP-384


As an extra, I already have patches for this proposal. They can be found here:

Branch: https://github.com/eduardo-elizondo/cpython/tree/heap-structseq
Reimplement PyStructSequence_NewType:  https://github.com/eduardo-elizondo/cpython/commit/413f8ca5bc008d84b3397ca1c9565c604d54b661
Patch timemodule with NewType: https://github.com/eduardo-elizondo/cpython/commit/0a35ea263a531cb03c06be9efc9e96d68162b308

Thoughts?

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://mail.python.org/pipermail/python-dev/attachments/20180904/dd580b85/attachment-0001.html>

From yselivanov.ml at gmail.com  Tue Sep  4 12:19:49 2018
From: yselivanov.ml at gmail.com (Yury Selivanov)
Date: Tue, 4 Sep 2018 12:19:49 -0400
Subject: [Python-Dev] Use of Cython
In-Reply-To: <pmf2kk$adv$1@blaine.gmane.org>
References: <CA+3bQGFzxdS=eBOyMWT-yHnP4pV=EukkbYKue6nPaAKk4713=w@mail.gmail.com>
 <20180730110120.6d03e6d8@fsol>
 <CA+3bQGGHjPJv6aL4t0T7iy9DGAc1xXSm+b_qxawEv=E2H_zoWw@mail.gmail.com>
 <74a848fa0eff42fc8ae5aa58e3fe71d0@xmail101.UGent.be>
 <5B600F47.3090503@UGent.be> <20180731094528.118471f9@fsol>
 <CADiSq7dKDSq7VsejP_FTDrSmvmeRcQmSD5OaVFO9qkwybtJqDg@mail.gmail.com>
 <17ebc01b-e0f2-1ebc-1229-b4ca84843f9c@python.org>
 <pk4e46$q92$1@blaine.gmane.org>
 <CADiSq7cKqgw=-AjDKCQ9QzGCN5yHOA+353cjkZvmdVvYN5qZpw@mail.gmail.com>
 <8CA25A41-D9F4-4634-9509-604F84B09E46@mac.com>
 <CADiSq7f0+CosMD5n2Ybbu90rQcJXq4Ska7KUn9smeaL=1XuMmA@mail.gmail.com>
 <2B17179F-29B4-40E2-824D-749359E33089@mac.com> <pk9oev$eh3$1@blaine.gmane.org>
 <57363ED3-4851-4A5D-A4B9-F9F0A9053F2C@mac.com>
 <CA+St6D1DNV3j9ieH-M9X0mkMH5mAXKYYOqBeDUWT952ZkCdNyA@mail.gmail.com>
 <pmf2kk$adv$1@blaine.gmane.org>
Message-ID: <CA+St6D1_jQNb1SQfKm1qja_d8qJNP5AhdTo1Zob0RXaqWeXe3w@mail.gmail.com>

Hi Stefan,

On Sat, Sep 1, 2018 at 6:12 PM Stefan Behnel <stefan_ml at behnel.de> wrote:
>
> Yury,
>
> given that people are starting to quote enthusiastically the comments you
> made below, let me set a couple of things straight.

To everyone reading this thread please keep in mind that I'm not in
position to "defend" mypyc or to "promote" it, and I'm not affiliated
with the project at all.  I am just excited about yet another tool to
statically compile Python and I'm discussing it only from a
theoretical standpoint.

>
> Yury Selivanov schrieb am 07.08.2018 um 19:34:
> > On Mon, Aug 6, 2018 at 11:49 AM Ronald Oussoren via Python-Dev wrote:
> >
> >> I have no strong opinion on using Cython for tests or in the stdlib, other than that it is a fairly large dependency.  I do think that adding a ?Cython-lite? tool the CPython distribution would be less ideal, creating and maintaining that tool would be a lot of work without clear benefits over just using Cython.
> >
> > Speaking of which, Dropbox is working on a new compiler they call "mypyc".
> >
> > mypyc will compile type-annotated Python code to an optimized C.
>
> That's their plan. Saying that "it will" is a bit premature at this point.
> The list of failed attempts at writing static Python compilers is rather
> long, even if you only count those that compile the usual "easy subset" of
> Python.
>
> I wish them the best of luck and endurance, but they have a long way to go.

I fully agree with you here.

>
>
> > The
> > first goal is to compile mypy with it to make it faster, so I hope
> > that the project will be completed.
>
> That's not "the first goal". It's the /only/ goal. The only intention of
> mypyc is to be able to compile and optimise enough of Python to speed up
> the kind or style of code that mypy uses.
>
>
> > Essentially, mypyc will be similar
> > to Cython, but mypyc is a *subset of Python*, not a superset.
>
> Which is bad, right? It means that there will be many things that simply
> don't work, and that you need to change your code in order to make it
> compile at all. Cython is way beyond that point by now. Even RPython will
> probably continue to be way better than mypyc for quite a while, maybe
> forever, who knows.

To be clear I'm not involved with mypyc, but my understanding is that
the entire Python syntax will be supported, except some dynamic
features like patching `globals()`, `locals()`, or classes, or
__class__.  IMO this is *good* and in general Python programs don't do
that anyways.

>
>
> > Interfacing with C libraries can be easily achieved with cffi.
>
> Except that it will be fairly slow. cffi is not designed for static
> analysis but for runtime operations.

Could you please clarify this point?  My current understanding is that
you can build a static compiler with a knowledge about cffi so that it
can compile calls like `ffi.new("something_t[]", 80)` to pure C.

> You can obviously also use cffi from
> Cython ? but then, why would you, if you can get much faster code much more
> easily without using cffi?

The "much more easily" part is debatable here and is highly
subjective.  For me using Cython is also easier *at this point*
because I've spent so much time working with it. Although getting
there wasn't easy for me :(

>
> That being said, if someone wants to write a static cffi optimiser for
> Cython, why not, I'd be happy to help with my advice. The cool thing is
> that this can be improved gradually, because compiling the cffi code
> probably already works out of the box. It's just not (much) faster than
> when interpreted.

Yeah, statically compiling cffi-enabled code is probably the way to go
for mypyc and Cython.

>
>
> > Being a
> > strict subset of Python means that mypyc code will execute just fine
> > in PyPy.
>
> So does normal (non-subset) Python code. You can run it in PyPy, have
> CPython interpret it, or compile it with Cython if you want it to run
> faster in CPython, all without having to limit yourself to a subset of
> Python. Seriously, you make this sound like requiring users to rewrite
> their code to make it compilable with mypyc was a good thing.

But that's the point: unless you add Cython types to your Python code
it gets only moderate speedups.  Using Cython/C types usually means
that you need to use pxd/pyx files which means that the code isn't
Python anymore.  I know that Cython has a mode to use decorators in
pure Python code to annotate types, but they are less intuitive than
using typing annotations in 3.6+.

[..]
> > I'd be more willing to start using mypyc+cffi in CPython stdlib
> > *eventually*, than Cython now.  Cython is a relatively complex and
> > still poorly documented language.
>
> You are free to improve the documentation or otherwise help us find and
> discuss concrete problems with it.

Fair point.

> Calling Cython a "poorly documented
> language" could easily feel offensive towards those who have put a lot of
> work into the documentation, wiki, tutorials, trainings and what not that
> help people use the language. Even stack overflow is getting better and
> better in documenting Cython these days, even though responses over there
> that describe work-arounds tend to get outdated fairly quickly.

Didn't mean to offend anyone, sorry if I did.  I'm myself partly
responsible for poor asyncio docs and I know how it is to be on the
receiving end :(

[..]
> > I'm speaking from experience after
> > writing thousands of lines of Cython in uvloop & asyncpg.  In skillful
> > hands Cython is amazing, but I'd be cautious to advertise and use it
> > in CPython.
>
> Why not? You didn't actually give any reasons for that.

I've listed a couple:

(1) To get significant speedup one needs to learn a lot of new syntax.
For CPython it means that we'd have Python, C, and Cython to learn to
understand code written in Cython.  There's a very popular assumption
that you have to be proficient in C in order to become a CPython core
dev and people are genuinely surprised when I tell them that it's not
a requirement.  At the three conferences I've been this summer at
least 5 people complained to me that they didn't even consider
contributing to CPython because they don't know C. Adding yet another
language would simply raise this bar even higher, IMHO.

(2) My point about documentation still stands, even though I feel
extremely uncomfortable using it, sorry.

>
>
> > I'm also -1 on using Cython to test C API. While writing C tests is
> > annoying (I wrote a fair share myself), their very purpose is to make
> > third-party tools/extensions more stable. Using a third-party tool to
> > test C API to track regressions that break third-party tools feels
> > wrong.
>
> I don't understand that argument. What's wrong about using a tool that
> helps you get around writing boiler plate code? The actual testing does not
> need to be done by Cython at all, you can write it any way you like.

Because you don't have 100% control over how exactly Cython (or
different versions of it) will compile your code to C.  In my
experience writing a few C API tests in C is relatively easy compared
to introducing these new C APIs in the first place.

To summarize my personal position:

I'm -1 on using Cython to write C API tests/boilerplate in CPython.

I'm -1 on giving green light to use Cython's pxd/pyx syntaxes in CPython.

I'd be +0.5 on using Cython (optionally?) to compile some pure Python
code to make it 30-50% faster.  asyncio, for instance, would certainly
benefit from that.

Y

From christian at python.org  Tue Sep  4 12:48:43 2018
From: christian at python.org (Christian Heimes)
Date: Tue, 4 Sep 2018 18:48:43 +0200
Subject: [Python-Dev] AES cipher implementation in standard library
In-Reply-To: <CAKyqbBqHOR7zuQ0ZPYSfB5H0U5Z3WRmmuZr5-Rf7Yf6d2zv-7g@mail.gmail.com>
References: <CAKyqbBqHOR7zuQ0ZPYSfB5H0U5Z3WRmmuZr5-Rf7Yf6d2zv-7g@mail.gmail.com>
Message-ID: <1b14178e-8cdb-5061-917e-6d63a0b3d832@python.org>

On 2018-09-04 16:37, ???? wrote:
> Dear all,
> 
> Have we tried?cipher?implementation includes AES as a standard library
> in the past?
> https://docs.python.org/3.6/library/crypto.html
> 
> if possible I want to try to implement AES because famous 3rd party
> library is not maintained and general cipher programs should be used for
> multiple purpose.Though the implementation is tough,? I believe this
> should be worth to it.
> In my case, I want to use AES implementation for zipfile module.

strong -1

The Python standard library doesn't contain any encryption, signing, and
other cryptographic algorithms for multiple reasons. The only exception
from the rule are hashing algorithms and HMAC construct. There are legal
implications like export restrictions. Crypto is just too hard to get
right and we don't want to give the user additional rope. We already had
a very lengthy and exhausting discussion for the secrets module. That
module just provides a user-friendly interface to CPRNG.

By the way, AES by itself is a useless to borderline dangerous
algorithm. It must be embedded within additional layers like block mode,
authenticated encryption / MAC, and more. There isn't a single correct
answer for block mode and AD algorithm, too. It highly depends on the
problem space. While GCM AEAD mode is good choice for network
communication, it can be a pretty bad idea for persistent storage.

There is one excellent Python library with high level and low level
cryptographic algorithms: http://cryptography.readthedocs.io/ . It's t

Regards,
Christian

From stefan_ml at behnel.de  Tue Sep  4 14:55:56 2018
From: stefan_ml at behnel.de (Stefan Behnel)
Date: Tue, 4 Sep 2018 20:55:56 +0200
Subject: [Python-Dev] Use of Cython
In-Reply-To: <CA+St6D1_jQNb1SQfKm1qja_d8qJNP5AhdTo1Zob0RXaqWeXe3w@mail.gmail.com>
References: <CA+3bQGFzxdS=eBOyMWT-yHnP4pV=EukkbYKue6nPaAKk4713=w@mail.gmail.com>
 <20180730110120.6d03e6d8@fsol>
 <CA+3bQGGHjPJv6aL4t0T7iy9DGAc1xXSm+b_qxawEv=E2H_zoWw@mail.gmail.com>
 <74a848fa0eff42fc8ae5aa58e3fe71d0@xmail101.UGent.be>
 <5B600F47.3090503@UGent.be> <20180731094528.118471f9@fsol>
 <CADiSq7dKDSq7VsejP_FTDrSmvmeRcQmSD5OaVFO9qkwybtJqDg@mail.gmail.com>
 <17ebc01b-e0f2-1ebc-1229-b4ca84843f9c@python.org>
 <pk4e46$q92$1@blaine.gmane.org>
 <CADiSq7cKqgw=-AjDKCQ9QzGCN5yHOA+353cjkZvmdVvYN5qZpw@mail.gmail.com>
 <8CA25A41-D9F4-4634-9509-604F84B09E46@mac.com>
 <CADiSq7f0+CosMD5n2Ybbu90rQcJXq4Ska7KUn9smeaL=1XuMmA@mail.gmail.com>
 <2B17179F-29B4-40E2-824D-749359E33089@mac.com>
 <pk9oev$eh3$1@blaine.gmane.org>
 <57363ED3-4851-4A5D-A4B9-F9F0A9053F2C@mac.com>
 <CA+St6D1DNV3j9ieH-M9X0mkMH5mAXKYYOqBeDUWT952ZkCdNyA@mail.gmail.com>
 <pmf2kk$adv$1@blaine.gmane.org>
 <CA+St6D1_jQNb1SQfKm1qja_d8qJNP5AhdTo1Zob0RXaqWeXe3w@mail.gmail.com>
Message-ID: <pmmkbp$hma$1@blaine.gmane.org>

Yury Selivanov schrieb am 04.09.2018 um 18:19:
> On Sat, Sep 1, 2018 at 6:12 PM Stefan Behnel wrote:
>> Yury Selivanov schrieb am 07.08.2018 um 19:34:
>>> The first goal is to compile mypy with it to make it faster, so I hope
>>> that the project will be completed.
>>
>> That's not "the first goal". It's the /only/ goal. The only intention of
>> mypyc is to be able to compile and optimise enough of Python to speed up
>> the kind or style of code that mypy uses.
>>
>>> Essentially, mypyc will be similar
>>> to Cython, but mypyc is a *subset of Python*, not a superset.
>>
>> Which is bad, right? It means that there will be many things that simply
>> don't work, and that you need to change your code in order to make it
>> compile at all. Cython is way beyond that point by now. Even RPython will
>> probably continue to be way better than mypyc for quite a while, maybe
>> forever, who knows.
> 
> To be clear I'm not involved with mypyc, but my understanding is that
> the entire Python syntax will be supported, except some dynamic
> features like patching `globals()`, `locals()`, or classes, or
> __class__.

No, that's not the goal, at least from what I understood from my
discussions with Jukka. The goal is to make it compile mypy, be it by
supporting Python features in mypyc or by avoiding Python features in mypy.
I'm sure they will take any shortcut they can in order to avoid having to
make mypyc too capable, because mypyc is not more than a means to an end.
For example, they may easily get away without supporting generators and
closures, which are quite difficult to implement in C. But finding a
non-trivial piece of Python code out there that uses neither of the two is
probably not easy.

I'm also sure they will avoid Python semantics wherever they can, because
implementing them in the same way as CPython and Cython would mean that
certain constructs cannot safely be statically reasoned about, and thus
cannot be optimised. Avoiding (full) Python semantics relieves you from
these restrictions, and if you control both sides, the compiler and the
code that it compiles, then it becomes much easier to apply arbitrary
optimisations at will.

IMHO, what they are implementing is much closer to ShedSkin than to Cython.


>>> Interfacing with C libraries can be easily achieved with cffi.
>>
>> Except that it will be fairly slow. cffi is not designed for static
>> analysis but for runtime operations.
> 
> Could you please clarify this point?  My current understanding is that
> you can build a static compiler with a knowledge about cffi so that it
> can compile calls like `ffi.new("something_t[]", 80)` to pure C.

I'm sure there is a relatively large subset of cffi's API that could be
compiled statically, as long as the declartions and their usage are kept
simple and fully visible to the compiler. What that subset is remains to be
seen once someone actually tries to do it.


> Yeah, statically compiling cffi-enabled code is probably the way to go
> for mypyc and Cython.

I doubt it, given the expected restrictions and verbosity. But debating
this is useless as long as no-one attempts to actually write a static
compiler for cffi(-like) code.


> Using Cython/C types usually means
> that you need to use pxd/pyx files which means that the code isn't
> Python anymore.

I'm aware that this is a very common misconception that is difficult to get
out of people's heads. You probably got this idea from wrapping a native
library, in which case the only choice you have in order to declare an
external C-API is really to use Cython's special syntax. However, this
would not apply to most use cases in the CPython project context, and it
also does not necessarily apply to most of the code in a Cython module even
if it uses external libraries.

Cython has four ways to provide type declarations: cdef statements in
Cython code, external .pxd files for Python or Cython files, special
decorators and declaration functions, and PEP-484/526 type annotations.

All four have their use cases (e.g. syntax support in different Python
versions, efficiency of expression, readability for people with different
backgrounds, etc.), and all but the first allow users to keep their module
code in Python syntax. As long as you do not call into external native
code, it's your choice which of these you prefer for your code base,
project context and developer background. You can even mix them at will, if
you feel like it.


> I know that Cython has a mode to use decorators in
> pure Python code to annotate types, but they are less intuitive than
> using typing annotations in 3.6+.

You can use PEP-484/526 type annotations to declare Cython types in Python
code that you intend to compile. It's entirely up to you, and it's an
entirely subjective measure which "is better". Many people prefer Cython's
non-Python syntax because it allows them to apply their existing C
knowledge. For them, PEP-484 annotations may easily be non-intuitive in
comparison.


> For CPython it means that we'd have Python, C, and Cython to learn to
> understand code written in Cython.  There's a very popular assumption
> that you have to be proficient in C in order to become a CPython core
> dev and people are genuinely surprised when I tell them that it's not
> a requirement.  At the three conferences I've been this summer at
> least 5 people complained to me that they didn't even consider
> contributing to CPython because they don't know C. Adding yet another
> language would simply raise this bar even higher, IMHO.

Adding the right language would lower the bar, IMHO. Cython is Python. It
allows users with a Python background to implement C things without having
to thoroughly learn C /and/ the CPython C-API first. So, the way I see it,
rather than /adding/ a "third" language to the mix, it substantially lowers
the entry level from the current two and a half languages (Python + C +
C-API) to one and a half (Python + Cython).


> I'd be +0.5 on using Cython (optionally?) to compile some pure Python
> code to make it 30-50% faster.  asyncio, for instance, would certainly
> benefit from that.

Since most of this (stdlib) Python code doesn't need to stay syntax
compatible with Python < 3.6 (actually 3.8) anymore, you can probably get
much higher speedups than that by statically typing some variables and
functions here and there. I recently tried that with difflib, makes a big
difference.

Stefan


From ethan at stoneleaf.us  Tue Sep  4 15:47:31 2018
From: ethan at stoneleaf.us (Ethan Furman)
Date: Tue, 04 Sep 2018 12:47:31 -0700
Subject: [Python-Dev] Use of Cython
In-Reply-To: <pmmkbp$hma$1@blaine.gmane.org>
References: <CA+3bQGFzxdS=eBOyMWT-yHnP4pV=EukkbYKue6nPaAKk4713=w@mail.gmail.com>
 <20180730110120.6d03e6d8@fsol>
 <CA+3bQGGHjPJv6aL4t0T7iy9DGAc1xXSm+b_qxawEv=E2H_zoWw@mail.gmail.com>
 <74a848fa0eff42fc8ae5aa58e3fe71d0@xmail101.UGent.be>
 <5B600F47.3090503@UGent.be> <20180731094528.118471f9@fsol>
 <CADiSq7dKDSq7VsejP_FTDrSmvmeRcQmSD5OaVFO9qkwybtJqDg@mail.gmail.com>
 <17ebc01b-e0f2-1ebc-1229-b4ca84843f9c@python.org>
 <pk4e46$q92$1@blaine.gmane.org>
 <CADiSq7cKqgw=-AjDKCQ9QzGCN5yHOA+353cjkZvmdVvYN5qZpw@mail.gmail.com>
 <8CA25A41-D9F4-4634-9509-604F84B09E46@mac.com>
 <CADiSq7f0+CosMD5n2Ybbu90rQcJXq4Ska7KUn9smeaL=1XuMmA@mail.gmail.com>
 <2B17179F-29B4-40E2-824D-749359E33089@mac.com>
 <pk9oev$eh3$1@blaine.gmane.org>
 <57363ED3-4851-4A5D-A4B9-F9F0A9053F2C@mac.com>
 <CA+St6D1DNV3j9ieH-M9X0mkMH5mAXKYYOqBeDUWT952ZkCdNyA@mail.gmail.com>
 <pmf2kk$adv$1@blaine.gmane.org>
 <CA+St6D1_jQNb1SQfKm1qja_d8qJNP5AhdTo1Zob0RXaqWeXe3w@mail.gmail.com>
 <pmmkbp$hma$1@blaine.gmane.org>
Message-ID: <5B8EE153.1020104@stoneleaf.us>

On 09/04/2018 11:55 AM, Stefan Behnel wrote:

> Adding the right language would lower the bar, IMHO. Cython is Python. It
> allows users with a Python background to implement C things without having
> to thoroughly learn C/and/  the CPython C-API first. So, the way I see it,
> rather than/adding/  a "third" language to the mix, it substantially lowers
> the entry level from the current two and a half languages (Python + C +
> C-API) to one and a half (Python + Cython).

As somebody who only has light exposure to C, I would very much like to have Cython be an option.

--
~Ethan~

From yselivanov.ml at gmail.com  Tue Sep  4 15:51:37 2018
From: yselivanov.ml at gmail.com (Yury Selivanov)
Date: Tue, 4 Sep 2018 15:51:37 -0400
Subject: [Python-Dev] Use of Cython
In-Reply-To: <pmmkbp$hma$1@blaine.gmane.org>
References: <CA+3bQGFzxdS=eBOyMWT-yHnP4pV=EukkbYKue6nPaAKk4713=w@mail.gmail.com>
 <20180730110120.6d03e6d8@fsol>
 <CA+3bQGGHjPJv6aL4t0T7iy9DGAc1xXSm+b_qxawEv=E2H_zoWw@mail.gmail.com>
 <74a848fa0eff42fc8ae5aa58e3fe71d0@xmail101.UGent.be>
 <5B600F47.3090503@UGent.be> <20180731094528.118471f9@fsol>
 <CADiSq7dKDSq7VsejP_FTDrSmvmeRcQmSD5OaVFO9qkwybtJqDg@mail.gmail.com>
 <17ebc01b-e0f2-1ebc-1229-b4ca84843f9c@python.org>
 <pk4e46$q92$1@blaine.gmane.org>
 <CADiSq7cKqgw=-AjDKCQ9QzGCN5yHOA+353cjkZvmdVvYN5qZpw@mail.gmail.com>
 <8CA25A41-D9F4-4634-9509-604F84B09E46@mac.com>
 <CADiSq7f0+CosMD5n2Ybbu90rQcJXq4Ska7KUn9smeaL=1XuMmA@mail.gmail.com>
 <2B17179F-29B4-40E2-824D-749359E33089@mac.com> <pk9oev$eh3$1@blaine.gmane.org>
 <57363ED3-4851-4A5D-A4B9-F9F0A9053F2C@mac.com>
 <CA+St6D1DNV3j9ieH-M9X0mkMH5mAXKYYOqBeDUWT952ZkCdNyA@mail.gmail.com>
 <pmf2kk$adv$1@blaine.gmane.org>
 <CA+St6D1_jQNb1SQfKm1qja_d8qJNP5AhdTo1Zob0RXaqWeXe3w@mail.gmail.com>
 <pmmkbp$hma$1@blaine.gmane.org>
Message-ID: <CA+St6D3K9HTcQHd-2fJRnBcREQc0xvaOM9LHAiF6oaZg7igu7w@mail.gmail.com>

On Tue, Sep 4, 2018 at 2:58 PM Stefan Behnel <stefan_ml at behnel.de> wrote:
[..]
> Cython has four ways to provide type declarations: cdef statements in
> Cython code, external .pxd files for Python or Cython files, special
> decorators and declaration functions, and PEP-484/526 type annotations.

Great to hear that PEP 484 type annotations are supported.  Here's a
link to the docs:
https://cython.readthedocs.io/en/latest/src/tutorial/pure.html#static-typing

[..]
> > I know that Cython has a mode to use decorators in
> > pure Python code to annotate types, but they are less intuitive than
> > using typing annotations in 3.6+.
>
> You can use PEP-484/526 type annotations to declare Cython types in Python
> code that you intend to compile. It's entirely up to you, and it's an
> entirely subjective measure which "is better". Many people prefer Cython's
> non-Python syntax because it allows them to apply their existing C
> knowledge. For them, PEP-484 annotations may easily be non-intuitive in
> comparison.

Yeah, but if we decide to use Cython in CPython we probably need to
come up with something like PEP 7 to recommend one particular style
and have an overall guideline.  Using PEP 484 annotations means that
we have pure Python code that PyPy and other interpreters can still
run.

[..]
> > I'd be +0.5 on using Cython (optionally?) to compile some pure Python
> > code to make it 30-50% faster.  asyncio, for instance, would certainly
> > benefit from that.
>
> Since most of this (stdlib) Python code doesn't need to stay syntax
> compatible with Python < 3.6 (actually 3.8) anymore, you can probably get
> much higher speedups than that by statically typing some variables and
> functions here and there. I recently tried that with difflib, makes a big
> difference.

I'd be willing to try this in asyncio if we start using Cython.

Yury

